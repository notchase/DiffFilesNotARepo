diff --git a/soh/assets/objects/gameplay_field_keep/gameplay_field_keep.h b/soh/assets/objects/gameplay_field_keep/gameplay_field_keep.h
index a007132c..28f853eb 100644
--- a/soh/assets/objects/gameplay_field_keep/gameplay_field_keep.h
+++ b/soh/assets/objects/gameplay_field_keep/gameplay_field_keep.h
@@ -186,5 +186,12 @@ static const ALIGN_ASSET(2) char gFieldUnusedFishSkelLimbsLimb_0088CCDL_006458[]
 #define dgFieldUnusedFishSkelLimbsLimb_0088D8DL_0061F8 "__OTR__objects/gameplay_field_keep/gFieldUnusedFishSkelLimbsLimb_0088D8DL_0061F8"
 static const ALIGN_ASSET(2) char gFieldUnusedFishSkelLimbsLimb_0088D8DL_0061F8[] = dgFieldUnusedFishSkelLimbsLimb_0088D8DL_0061F8;
 
+//CUSTOM
+#define dgGliderDL "__OTR__objects/gameplay_field_keep/gGliderDL" 
+static const ALIGN_ASSET(2) char gGliderDL[] = dgGliderDL;
+
+#define dgLanternDL "__OTR__objects/gameplay_field_keep/gLanternDL"
+static const ALIGN_ASSET(2) char gLanternDL[] = dgLanternDL;
+
 
 #endif // OBJECTS_GAMEPLAY_FIELD_KEEP_H
diff --git a/soh/assets/textures/icon_item_static/icon_item_static.h b/soh/assets/textures/icon_item_static/icon_item_static.h
index c3230585..b141fd28 100644
--- a/soh/assets/textures/icon_item_static/icon_item_static.h
+++ b/soh/assets/textures/icon_item_static/icon_item_static.h
@@ -561,4 +561,18 @@ static const ALIGN_ASSET(2) char gPromptCursorLeftDL[] = dgPromptCursorLeftDL;
 #define dgPromptCursorRightDL "__OTR__textures/icon_item_static/gPromptCursorRightDL"
 static const ALIGN_ASSET(2) char gPromptCursorRightDL[] = dgPromptCursorRightDL;
 
+//CUSTOM
+#define dgJumpIconTex "__OTR__textures/icon_item_static/gJumpIconTex"
+static const ALIGN_ASSET(2) char gJumpIconTex[] = dgJumpIconTex;
+
+#define dgGliderIconTex "__OTR__textures/icon_item_static/gGliderIconTex"
+static const ALIGN_ASSET(2) char gGliderIconTex[] = dgGliderIconTex;
+
+#define dgLanternIconTex "__OTR__textures/icon_item_static/gLanternIconTex"
+static const ALIGN_ASSET(2) char gLanternIconTex[] = dgLanternIconTex;
+
+#define dgStasisIconTex "__OTR__textures/icon_item_static/gStasisIconTex"
+static const ALIGN_ASSET(2) char gStasisIconTex[] = dgStasisIconTex;
+
+
 #endif // TEXTURES_ICON_ITEM_STATIC_H
diff --git a/soh/assets/textures/item_name_static/item_name_static.h b/soh/assets/textures/item_name_static/item_name_static.h
index 86af0cab..1e14c165 100644
--- a/soh/assets/textures/item_name_static/item_name_static.h
+++ b/soh/assets/textures/item_name_static/item_name_static.h
@@ -1110,4 +1110,21 @@ static const ALIGN_ASSET(2) char gUnusedBossKeyItemName21JPNTex[] = dgUnusedBoss
 #define dgBiggoronsSwordItemNameFRATex "__OTR__textures/item_name_static/gBiggoronsSwordItemNameFRATex"
 static const ALIGN_ASSET(2) char gBiggoronsSwordItemNameFRATex[] = dgBiggoronsSwordItemNameFRATex;
 
-#endif // TEXTURES_ITEM_NAME_STATIC_H
+//CUSTOM
+#define dgBlankItemNameENGTex "__OTR__textures/item_name_static/gBlankItemNameENGTex"
+static const ALIGN_ASSET(2) char gBlankItemNameENGTex[] = dgBlankItemNameENGTex;
+
+#define dgSSBJumpItemNameENGTex "__OTR__textures/item_name_static/gSSBJumpItemNameENGTex"
+static const ALIGN_ASSET(2) char gSSBJumpItemNameENGTex[] = dgSSBJumpItemNameENGTex;
+
+#define dgGliderItemNameENGTex "__OTR__textures/item_name_static/gGliderItemNameENGTex"
+static const ALIGN_ASSET(2) char gGliderItemNameENGTex[] = dgGliderItemNameENGTex;
+
+#define dgLanternItemNameENGTex "__OTR__textures/item_name_static/gLanternItemNameENGTex"
+static const ALIGN_ASSET(2) char gLanternItemNameENGTex[] = dgLanternItemNameENGTex;
+
+#define dgStasisItemNameENGTex "__OTR__textures/item_name_static/gStasisItemNameENGTex"
+static const ALIGN_ASSET(2) char gStasisItemNameENGTex[] = dgStasisItemNameENGTex;
+
+
+#endif // TEXTURES_ITEM_NAME_STATIC_H
\ No newline at end of file
diff --git a/soh/assets/textures/parameter_static/parameter_static.h b/soh/assets/textures/parameter_static/parameter_static.h
index c7be020a..e282dfe1 100644
--- a/soh/assets/textures/parameter_static/parameter_static.h
+++ b/soh/assets/textures/parameter_static/parameter_static.h
@@ -171,4 +171,9 @@ static const ALIGN_ASSET(2) char gMagicMeterMidTex[] = dgMagicMeterMidTex;
 #define dgMagicMeterFillTex "__OTR__textures/parameter_static/gMagicMeterFillTex"
 static const ALIGN_ASSET(2) char gMagicMeterFillTex[] = dgMagicMeterFillTex;
 
+
+//CUSTOM
+#define dgCrosshairTex "__OTR__textures/parameter_static/gCrosshairTex"
+static const ALIGN_ASSET(2) char gCrosshairTex[] = dgCrosshairTex;
+
 #endif // TEXTURES_PARAMETER_STATIC_H
diff --git a/soh/include/functions.h b/soh/include/functions.h
index 3a1aa8ae..46a311cd 100644
--- a/soh/include/functions.h
+++ b/soh/include/functions.h
@@ -416,7 +416,7 @@ void func_8002DBD0(Actor* actor, Vec3f* result, Vec3f* arg2);
 f32 Actor_HeightDiff(Actor* actorA, Actor* actorB);
 f32 Player_GetHeight(Player* player);
 f32 func_8002DCE4(Player* player);
-s32 func_8002DD6C(Player* player);
+s32 PlayerStateItemInHand(Player* player);
 s32 func_8002DD78(Player* player);
 s32 func_8002DDE4(PlayState* play);
 s32 func_8002DDF4(PlayState* play);
@@ -1107,7 +1107,7 @@ u8 PlayerGrounded(Player* player);
 void Player_SetBootData(PlayState* play, Player* player);
 s32 Player_InBlockingCsMode(PlayState* play, Player* player);
 s32 Player_InCsMode(PlayState* play);
-s32 func_8008E9C4(Player* player);
+s32 Is_PLAYER_STATE1_ENEMY_TARGET(Player* player);
 s32 Player_IsChildWithHylianShield(Player* player);
 s32 Player_ActionToModelGroup(Player* player, s32 actionParam);
 void Player_SetModelsForHoldingShield(Player* player);
diff --git a/soh/include/tables/actor_table.h b/soh/include/tables/actor_table.h
index d05085f4..06871735 100644
--- a/soh/include/tables/actor_table.h
+++ b/soh/include/tables/actor_table.h
@@ -480,4 +480,10 @@
 /* 0x01D3 */ DEFINE_ACTOR(En_Zl4, ACTOR_EN_ZL4, ALLOCTYPE_NORMAL)
 /* 0x01D4 */ DEFINE_ACTOR(En_Mm2, ACTOR_EN_MM2, ALLOCTYPE_NORMAL)
 /* 0x01D5 */ DEFINE_ACTOR(Bg_Jya_Block, ACTOR_BG_JYA_BLOCK, ALLOCTYPE_NORMAL)
-/* 0x01D6 */ DEFINE_ACTOR(Obj_Warp2block, ACTOR_OBJ_WARP2BLOCK, ALLOCTYPE_NORMAL)
\ No newline at end of file
+/* 0x01D6 */ DEFINE_ACTOR(Obj_Warp2block, ACTOR_OBJ_WARP2BLOCK, ALLOCTYPE_NORMAL)
+
+//CUSTOM
+/* 0x0019 */ DEFINE_ACTOR(En_Glider, ACTOR_EN_GLIDER, ALLOCTYPE_NORMAL)
+/* 0x0019 */ DEFINE_ACTOR(Lantern_Fire, ACTOR_LANTERN_FIRE, ALLOCTYPE_NORMAL)
+/* 0x0019 */ DEFINE_ACTOR(Wind_Zone, ACTOR_WIND_ZONE, ALLOCTYPE_NORMAL)
+/* 0x0019 */ DEFINE_ACTOR(Custom_Projectile, ACTOR_CUSTOM_PROJECTILE, ALLOCTYPE_PERMANENT)
\ No newline at end of file
diff --git a/soh/include/tables/object_table.h b/soh/include/tables/object_table.h
index 97e6aa25..184d2d7b 100644
--- a/soh/include/tables/object_table.h
+++ b/soh/include/tables/object_table.h
@@ -409,3 +409,7 @@
 /* 0x018F */ DEFINE_OBJECT(object_ouke_haka, OBJECT_OUKE_HAKA)
 /* 0x0190 */ DEFINE_OBJECT(object_timeblock, OBJECT_TIMEBLOCK)
 /* 0x0191 */ DEFINE_OBJECT(object_zl4, OBJECT_ZL4)
+
+//CUSTOM
+/* 0x0013 */ DEFINE_OBJECT(object_glider, OBJECT_GLIDER)
+/* 0x0013 */ DEFINE_OBJECT(object_lantern, OBJECT_LANTERN)
diff --git a/soh/include/variables.h b/soh/include/variables.h
index 2bad8335..ef2d9289 100644
--- a/soh/include/variables.h
+++ b/soh/include/variables.h
@@ -99,7 +99,7 @@ extern "C"
 	extern u16 gUpgradeCapacities[8][4];
 	extern u32 gGsFlagsMasks[4];
 	extern u32 gGsFlagsShifts[4];
-	extern void* gItemIcons[0x82];
+	extern void* gItemIcons[0xA4]; //INCREASE WITH CUSTOM ITEMS
 	extern u8 gItemAgeReqs[];
 	extern u8 gSlotAgeReqs[];
 	extern u8 gItemSlots[56];
diff --git a/soh/include/z64item.h b/soh/include/z64item.h
index 1fc919a4..2fd9a6f3 100644
--- a/soh/include/z64item.h
+++ b/soh/include/z64item.h
@@ -146,6 +146,12 @@ typedef enum {
     /* 0x1B */ SLOT_BOOTS_KOKIRI,
     /* 0x1C */ SLOT_BOOTS_IRON,
     /* 0x1D */ SLOT_BOOTS_HOVER,
+    //CUSTOM
+    SLOT_JUMP = 0xA0, //160
+    SLOT_GLIDER = 0xA1, //161
+    SLOT_LANTERN = 0xA2, //162
+    SLOT_STASIS = 0xA3, //163
+    SLOT_CUSTOM_MAX = 0xA4,
     /* 0xFF */ SLOT_NONE = 0xFF
 } InventorySlot;
 
@@ -306,6 +312,12 @@ typedef enum {
     /* 0x99 */ ITEM_STICK_UPGRADE_30,
     /* 0x9A */ ITEM_NUT_UPGRADE_30,
     /* 0x9B */ ITEM_NUT_UPGRADE_40,
+        //CUSTOM
+               ITEM_JUMP = 0xA0, //160
+               ITEM_GLIDER = 0xA1, //161
+               ITEM_LANTERN = 0xA2, //161
+               ITEM_STASIS = 0xA3,
+               ITEM_CUSTOM_MAX = 0xA4,
     /* 0xFC */ ITEM_LAST_USED = 0xFC,
     /* 0xFE */ ITEM_NONE_FE = 0xFE,
     /* 0xFF */ ITEM_NONE = 0xFF
@@ -442,6 +454,12 @@ typedef enum {
     /* 0x7B */ GI_BULLET_BAG_50,
     /* 0x7C */ GI_ICE_TRAP, // freezes link when opened from a chest
     /* 0x7D */ GI_TEXT_0,   // no model appears over Link, shows text id 0 (pocket egg)
+        //CUSTOM
+               GI_JUMP = 0xA0, //160
+               GI_GLIDER = 0xA1, //161
+               GI_LANTERN = 0xA2, //162
+               GI_STASIS = 0xA3, //163
+               GI_CUSTOM_MAX = 0xA4, 
     /* 0x84 */ GI_MAX
 } GetItemID;
 
diff --git a/soh/include/z64player.h b/soh/include/z64player.h
index ff30cc17..787503df 100644
--- a/soh/include/z64player.h
+++ b/soh/include/z64player.h
@@ -142,6 +142,17 @@ typedef enum {
     /* 0x49 */ PLAYER_IA_BOOTS_KOKIRI,
     /* 0x4A */ PLAYER_IA_BOOTS_IRON,
     /* 0x4B */ PLAYER_IA_BOOTS_HOVER,
+    //CUSTOM
+    //PLAYER_IA_JUMP = 0xA0, //160
+    //PLAYER_IA_GLIDER = 0xA1, //161
+    //PLAYER_IA_LANTERN = 0xA2, //161
+    //PLAYER_IA_STASIS = 0xA3,
+    //PLAYER_IA_CUSTOM_MAX = 0xA4,
+               PLAYER_IA_JUMP,
+               PLAYER_IA_GLIDER,
+               PLAYER_IA_LANTERN,
+               PLAYER_IA_STASIS,
+               PLAYER_IA_CUSTOM_MAX,
     /* 0x4C */ PLAYER_IA_MAX
 } PlayerItemAction;
 
@@ -249,6 +260,7 @@ typedef enum {
     /* 0x0C */ PLAYER_MODELGROUP_OCARINA, // ocarina
     /* 0x0D */ PLAYER_MODELGROUP_OOT, // ocarina of time
     /* 0x0E */ PLAYER_MODELGROUP_BOTTLE, // bottles (drawn separately)
+    /* 0x0E */ PLAYER_MODELGROUP_LANTERN, // bottles (drawn separately)
     /* 0x0F */ PLAYER_MODELGROUP_15, // "last used"
     /* 0x10 */ PLAYER_MODELGROUP_MAX
 } PlayerModelGroup;
@@ -272,6 +284,7 @@ typedef enum {
     /* 0x05 */ PLAYER_MODELTYPE_LH_HAMMER, // holding hammer (child: empty hand)
     /* 0x06 */ PLAYER_MODELTYPE_LH_BOOMERANG, // holding boomerang (adult: empty hand)
     /* 0x07 */ PLAYER_MODELTYPE_LH_BOTTLE, // holding bottle (bottle drawn separately)
+    /* 0x07 */ PLAYER_MODELTYPE_LH_LANTERN, // holding bottle (bottle drawn separately)
     // right hand
     /* 0x08 */ PLAYER_MODELTYPE_RH_OPEN, // empty open hand
     /* 0x09 */ PLAYER_MODELTYPE_RH_CLOSED, // empty closed hand
@@ -419,11 +432,11 @@ typedef struct {
 } PendingFlag; // size = 0x06
 // #endregion
 
-#define PLAYER_STATE1_LOADING (1 << 0) //Transitioning to a new scene
-#define PLAYER_STATE1_SWINGING_BOTTLE (1 << 1)
-#define PLAYER_STATE1_HOOKSHOT_FALLING (1 << 2)
-#define PLAYER_STATE1_ITEM_IN_HAND (1 << 3)
-#define PLAYER_STATE1_ENEMY_TARGET (1 << 4)
+#define PLAYER_STATE1_LOADING (1 << 0) //Transitioning to a new scene //0x0001
+#define PLAYER_STATE1_SWINGING_BOTTLE (1 << 1) //0x0002
+#define PLAYER_STATE1_HOOKSHOT_FALLING (1 << 2)//0x0004
+#define PLAYER_STATE1_ITEM_IN_HAND (1 << 3) //0x0008
+#define PLAYER_STATE1_ENEMY_TARGET (1 << 4) //0x0010
 #define PLAYER_STATE1_INPUT_DISABLED (1 << 5)
 #define PLAYER_STATE1_TEXT_ON_SCREEN (1 << 6)
 #define PLAYER_STATE1_DEAD (1 << 7) 
@@ -494,6 +507,16 @@ typedef struct {
 #define PLAYER_STATE3_RESTORE_NAYRUS_LOVE (1 << 6) // Set by ocarina effects actors when destroyed to signal Nayru's Love may be restored (see `ACTOROVL_ALLOC_ABSOLUTE`)
 #define PLAYER_STATE3_HOOKSHOT_TRAVELLING (1 << 7) //Travelling to target
 
+#define PLAYER_STATE4_0 (1 << 0)
+#define PLAYER_STATE4_1FIRST_PERSON_AND_MORE (1 << 1)
+#define PLAYER_STATE4_2 (1 << 2)
+#define PLAYER_STATE4_3 (1 << 3)
+#define PLAYER_STATE4_4FOCUS_HEAD_ROTATION_Y (1 << 4)
+#define PLAYER_STATE4_5 (1 << 5) 
+#define PLAYER_STATE4_6 (1 << 6)
+#define PLAYER_STATE4_7 (1 << 7)
+#define PLAYER_STATE4_8READY_TO_FIRE (1 << 8)
+
 typedef void (*PlayerFunc674)(struct Player*, struct PlayState*);
 typedef s32 (*PlayerFunc82C)(struct Player*, struct PlayState*);
 typedef void (*PlayerFuncA74)(struct PlayState*, struct Player*);
@@ -563,7 +586,7 @@ typedef struct Player {
     /* 0x0498 */ ColliderCylinder cylinder;
     /* 0x04E4 */ ColliderQuad meleeWeaponQuads[2];
     /* 0x05E4 */ ColliderQuad shieldQuad;
-    /* 0x0664 */ Actor*     unk_664;
+    /* 0x0664 */ Actor*     targetActorMaybe; //unk_664;;
     /* 0x0668 */ char       unk_668[0x004];
     /* 0x066C */ s32        unk_66C;
     /* 0x0670 */ s32        meleeWeaponEffectIndex;
@@ -588,12 +611,12 @@ typedef struct Player {
     /* 0x06AE */ u16        unk_6AE;
     /* 0x06B0 */ s16        unk_6B0;
     /* 0x06B2 */ char       unk_6B4[0x004];
-    /* 0x06B6 */ s16        unk_6B6;
-    /* 0x06B8 */ s16        unk_6B8;
-    /* 0x06BA */ s16        unk_6BA;
-    /* 0x06BC */ s16        unk_6BC;
+    /* 0x06B6 */ s16        runningHeadForwardRotation;
+    /* 0x06B8 */ s16        focusHeadYRotation;
+    /* 0x06BA */ s16        runningHeadLeanRotation;
+    /* 0x06BC */ s16        runningTorsoForwardRotation;
     /* 0x06BE */ s16        unk_6BE;
-    /* 0x06C0 */ s16        unk_6C0;
+    /* 0x06C0 */ s16        readyToFireTorsoRotZ;
     /* 0x06C2 */ s16        unk_6C2;
     /* 0x06C4 */ f32        unk_6C4;
     /* 0x06C8 */ SkelAnime  skelAnime2;
@@ -684,6 +707,10 @@ typedef struct Player {
     // #endregion
     u8 ivanFloating;
     u8 ivanDamageMultiplier;
+
+    //CUSTOM
+    bool thirdPersonAiming;
+    Actor* customProjectile;
 } Player; // size = 0xA94
 
 #endif
diff --git a/soh/include/z64save.h b/soh/include/z64save.h
index c7bee045..bc0a9c94 100644
--- a/soh/include/z64save.h
+++ b/soh/include/z64save.h
@@ -44,7 +44,9 @@ typedef struct {
 
 typedef struct {
     /* 0x00 */ u8 items[24];
+               u8 items2[24];
     /* 0x18 */ s8 ammo[16];
+    /* 0x18 */ s8 ammo2[16];
     /* 0x28 */ u16 equipment; // a mask where each nibble corresponds to a type of equipment `EquipmentType`, and each bit to an owned piece `EquipInv*`
     /* 0x2C */ u32 upgrades;
     /* 0x30 */ u32 questItems;
diff --git a/soh/soh/ActorDB.cpp b/soh/soh/ActorDB.cpp
index a66048b3..c4fab118 100644
--- a/soh/soh/ActorDB.cpp
+++ b/soh/soh/ActorDB.cpp
@@ -462,7 +462,12 @@ static std::unordered_map<u16, const char*> actorDescriptions = {
     { ACTOR_EN_ZL4, "Zelda (Child)" },
     { ACTOR_EN_MM2, "Running Man (Adult Era)" },
     { ACTOR_BG_JYA_BLOCK, "Silver Block (Child Era)" },
-    { ACTOR_OBJ_WARP2BLOCK, "Navi Infospot (Green, Time Block)" }
+    { ACTOR_OBJ_WARP2BLOCK, "Navi Infospot (Green, Time Block)" },
+        //CUSTOM
+    { ACTOR_EN_GLIDER, "Glider" },
+    { ACTOR_LANTERN_FIRE, "Lantern Fire" },
+    { ACTOR_WIND_ZONE, "Wind Zone" },
+    { ACTOR_CUSTOM_PROJECTILE, "Custom Projectile" },
 };
 
 ActorDB::ActorDB() {
diff --git a/soh/src/code/code_80097A00.c b/soh/src/code/code_80097A00.c
index eb83738e..18af993b 100644
--- a/soh/src/code/code_80097A00.c
+++ b/soh/src/code/code_80097A00.c
@@ -167,6 +167,41 @@ void* gItemIcons[] = {
     gOcarinaBtnIconCLeftTex,
     gOcarinaBtnIconCRightTex,
     gOcarinaBtnIconATex,
+        131,
+        132,
+        133,
+        134,
+        135,
+        136,
+        137,
+        138,
+        139,
+        140,
+        141,
+        142,
+        143,
+        144,
+        145,
+        146,
+        147,
+        148,
+        149,
+        150,
+        151,
+        152,
+        153,
+        154,
+        155,
+        156,
+        157,
+        158,
+        159,
+        160,
+        //CUSTOM
+        gJumpIconTex, //SSBJUMP
+        gGliderIconTex, //Glider
+        gLanternIconTex, //Lantern
+        gStasisIconTex, //Stasis
 };
 
 // Used to map item IDs to inventory slots
diff --git a/soh/src/code/z_actor.c b/soh/src/code/z_actor.c
index 79a3c8ac..1472a54f 100644
--- a/soh/src/code/z_actor.c
+++ b/soh/src/code/z_actor.c
@@ -486,7 +486,7 @@ void func_8002C124(TargetContext* targetCtx, PlayState* play) {
 
         func_8002BE64(targetCtx, targetCtx->unk_4C, spBC.x, spBC.y, spBC.z);
 
-        if ((!(player->stateFlags1 & 0x40)) || (actor != player->unk_664)) {
+        if ((!(player->stateFlags1 & 0x40)) || (actor != player->targetActorMaybe)) {
             OVERLAY_DISP = Gfx_SetupDL(OVERLAY_DISP, 0x39);
 
             for (spB0 = 0, spAC = targetCtx->unk_4C; spB0 < spB8; spB0++, spAC = (spAC + 1) % 3) {
@@ -564,7 +564,7 @@ void func_8002C7BC(TargetContext* targetCtx, Player* player, Actor* actorArg, Pl
 
     unkActor = NULL;
 
-    if ((player->unk_664 != NULL) && (player->unk_84B[player->unk_846] == 2)) {
+    if ((player->targetActorMaybe != NULL) && (player->unk_84B[player->unk_846] == 2)) {
         targetCtx->unk_94 = NULL;
     } else {
         func_80032AF0(play, &play->actorCtx, &unkActor, player);
@@ -1376,12 +1376,13 @@ f32 func_8002DCE4(Player* player) {
     }
 }
 
-s32 func_8002DD6C(Player* player) {
-    return player->stateFlags1 & 0x8;
+s32 PlayerStateItemInHand(Player* player) {
+    if (player->stateFlags1 & PLAYER_STATE1_ITEM_IN_HAND) return 1;
+    else return 0;
 }
 
 s32 func_8002DD78(Player* player) {
-    return func_8002DD6C(player) && player->unk_834;
+    return PlayerStateItemInHand(player) && player->unk_834;
 }
 
 s32 func_8002DDA8(PlayState* play) {
@@ -1844,7 +1845,7 @@ f32 func_8002EFC0(Actor* actor, Player* player, s16 arg2) {
     s16 yawTemp = (s16)(actor->yawTowardsPlayer - 0x8000) - arg2;
     s16 yawTempAbs = ABS(yawTemp);
 
-    if (player->unk_664 != NULL) {
+    if (player->targetActorMaybe != NULL) {
         if ((yawTempAbs > 0x4000) || (actor->flags & ACTOR_FLAG_NO_LOCKON)) {
             return FLT_MAX;
         } else {
@@ -1890,7 +1891,7 @@ s32 func_8002F0C8(Actor* actor, Player* player, s32 flag) {
         s16 abs_var = ABS(var);
         f32 dist;
 
-        if ((player->unk_664 == NULL) && (abs_var > 0x2AAA)) {
+        if ((player->targetActorMaybe == NULL) && (abs_var > 0x2AAA)) {
             dist = FLT_MAX;
         } else {
             dist = actor->xyzDistToPlayerSq;
@@ -2576,13 +2577,13 @@ void Actor_UpdateAll(PlayState* play, ActorContext* actorCtx) {
                 actor->flags &= ~ACTOR_FLAG_PLAY_HIT_SFX;
 
                 if ((DECR(actor->freezeTimer) == 0) && (actor->flags & (ACTOR_FLAG_UPDATE_WHILE_CULLED | ACTOR_FLAG_ACTIVE))) {
-                    if (actor == player->unk_664) {
+                    if (actor == player->targetActorMaybe) {
                         actor->isTargeted = true;
                     } else {
                         actor->isTargeted = false;
                     }
 
-                    if ((actor->targetPriority != 0) && (player->unk_664 == NULL)) {
+                    if ((actor->targetPriority != 0) && (player->targetActorMaybe == NULL)) {
                         actor->targetPriority = 0;
                     }
 
@@ -2606,7 +2607,7 @@ void Actor_UpdateAll(PlayState* play, ActorContext* actorCtx) {
         }
     }
 
-    actor = player->unk_664;
+    actor = player->targetActorMaybe;
 
     if ((actor != NULL) && (actor->update == NULL)) {
         actor = NULL;
@@ -2680,19 +2681,28 @@ void Actor_Draw(PlayState* play, Actor* actor) {
 
     if (actor->colorFilterTimer != 0) {
         Color_RGBA8 color = { 0, 0, 0, 255 };
-
-        if (actor->colorFilterParams & 0x8000) {
-            color.r = color.g = color.b = ((actor->colorFilterParams & 0x1F00) >> 5) | 7;
-        } else if (actor->colorFilterParams & 0x4000) {
-            color.r = ((actor->colorFilterParams & 0x1F00) >> 5) | 7;
-        } else {
-            color.b = ((actor->colorFilterParams & 0x1F00) >> 5) | 7;
+        Color_RGBA8 colorTeal = { 0, 255, 128, 255 };
+        if (actor->colorFilterParams == 0x0001) { //Custom Teal
+            func_80026400(play, &colorTeal, actor->colorFilterTimer, actor->colorFilterTimer & 0xFF);
         }
+        else {
 
-        if (actor->colorFilterParams & 0x2000) {
-            func_80026860(play, &color, actor->colorFilterTimer, actor->colorFilterParams & 0xFF);
-        } else {
-            func_80026400(play, &color, actor->colorFilterTimer, actor->colorFilterParams & 0xFF);
+            if (actor->colorFilterParams & 0x8000) {
+                color.r = color.g = color.b = ((actor->colorFilterParams & 0x1F00) >> 5) | 7;
+            }
+            else if (actor->colorFilterParams & 0x4000) {
+                color.r = ((actor->colorFilterParams & 0x1F00) >> 5) | 7;
+            }
+            else {
+                color.b = ((actor->colorFilterParams & 0x1F00) >> 5) | 7;
+            }
+
+            if (actor->colorFilterParams & 0x2000) {
+                func_80026860(play, &color, actor->colorFilterTimer, actor->colorFilterParams & 0xFF);
+            }
+            else {
+                func_80026400(play, &color, actor->colorFilterTimer, actor->colorFilterParams & 0xFF);
+            }
         }
     }
 
@@ -3305,7 +3315,7 @@ Actor* Actor_Delete(ActorContext* actorCtx, Actor* actor, PlayState* play) {
         osSyncPrintf("アクタークラス削除 [%s]\n", dbEntry->name); // "Actor class deleted [%s]"
     }
 
-    if ((player != NULL) && (actor == player->unk_664)) {
+    if ((player != NULL) && (actor == player->targetActorMaybe)) {
         func_8008EDF0(player);
         Camera_ChangeMode(Play_GetCamera(play, Play_GetActiveCamId(play)), 0);
     }
@@ -3360,7 +3370,7 @@ void func_800328D4(PlayState* play, ActorContext* actorCtx, Player* player, u32
     Vec3f sp70;
 
     actor = actorCtx->actorLists[actorCategory].head;
-    sp84 = player->unk_664;
+    sp84 = player->targetActorMaybe;
 
     while (actor != NULL) {
         if ((actor->update != NULL) && ((Player*)actor != player) && CHECK_FLAG_ALL(actor->flags, ACTOR_FLAG_TARGETABLE)) {
@@ -3710,8 +3720,8 @@ Actor* Actor_GetProjectileActor(PlayState* play, Actor* refActor, f32 radius) {
     Vec3f sp84;
 
     actor = play->actorCtx.actorLists[ACTORCAT_ITEMACTION].head;
-    while (actor != NULL) {
-        if (((actor->id != ACTOR_ARMS_HOOK) && (actor->id != ACTOR_EN_ARROW)) || (actor == refActor)) {
+    while (actor != NULL) {//CUSTOM
+        if (((actor->id != ACTOR_ARMS_HOOK) && (actor->id != ACTOR_EN_ARROW) && (actor->id != ACTOR_CUSTOM_PROJECTILE)) || (actor == refActor)) {
             actor = actor->next;
         } else {
             //! @bug The projectile actor gets unsafely casted to a hookshot to check its timer, even though
diff --git a/soh/src/code/z_camera.c b/soh/src/code/z_camera.c
index a177e29e..14335918 100644
--- a/soh/src/code/z_camera.c
+++ b/soh/src/code/z_camera.c
@@ -1523,11 +1523,101 @@ s32 Camera_Free(Camera* camera) {
     return 1;
 }
 
+s32 Camera_ThirdPersonAim(Camera* camera) {
+    Vec3f* eye = &camera->eye;
+    Vec3f* at = &camera->at;
+    Vec3f* eyeNext = &camera->eyeNext;
+    VecSph spA8;
+    CamColChk sp6C;
+    Parallel1* para1 = (Parallel1*)camera->paramData;
+    f32 playerHeight;
+
+    at->x = Camera_LERPCeilF(camera->player->actor.world.pos.x, camera->at.x, 0.5f, 1.0f);
+    at->y = Camera_LERPCeilF(camera->player->actor.world.pos.y + 25.0f + (camera->player->rideActor != NULL
+        ? Player_GetHeight(camera->player) / 2
+        : Player_GetHeight(camera->player)) /
+        1.2f,
+        camera->at.y, 0.5f, 1.0f);
+    at->z = Camera_LERPCeilF(camera->player->actor.world.pos.z, camera->at.z, 0.5f, 1.0f);
+
+    playerHeight = Player_GetHeight(camera->player) +10.0f;
+
+    if (RELOAD_PARAMS) {
+        OLib_Vec3fDiffToVecSphGeo(&spA8, &camera->at, &camera->eye);
+
+        CameraModeValue* values = sCameraSettings[camera->setting].cameraModes[camera->mode].values;
+        f32 yNormal = (1.0f + PCT(OREG(46))) - (PCT(OREG(46)) * (68.0f / playerHeight));
+
+        para1->yOffset = NEXTPCT * playerHeight * yNormal;
+        para1->distTarget = NEXTPCT * playerHeight * yNormal;
+        para1->pitchTarget = DEGF_TO_BINANG(NEXTSETTING);
+        para1->yawTarget = DEGF_TO_BINANG(NEXTSETTING);
+        para1->unk_08 = NEXTSETTING;
+        para1->unk_0C = NEXTSETTING;
+        para1->fovTarget = NEXTSETTING;
+        para1->unk_14 = NEXTPCT;
+        para1->interfaceFlags = NEXTSETTING;
+        para1->unk_18 = NEXTPCT * playerHeight * yNormal;
+        para1->unk_1C = NEXTPCT;
+    }
+
+    if (R_RELOAD_CAM_PARAMS) {
+        Camera_CopyPREGToModeValues(camera);
+    }
+
+    sCameraInterfaceFlags = 1;
+
+    camera->animState = 0;
+
+    f32 newCamX = -D_8015BD7C->state.input[0].cur.stick_x * 10.0f * (CVarGetFloat("gThirdPersonCameraSensitivityX", 1.0f));
+    f32 newCamY = D_8015BD7C->state.input[0].cur.stick_y * -10.0f * (CVarGetFloat("gThirdPersonCameraSensitivityY", 1.0f));
+    bool invertXAxis = (CVarGetInteger("gInvertXAxis", 0) && !CVarGetInteger("gMirroredWorld", 0)) || (!CVarGetInteger("gInvertXAxis", 0) && CVarGetInteger("gMirroredWorld", 0));
+
+    camera->play->camX += newCamX * (invertXAxis ? -1 : 1);
+    camera->play->camY += newCamY * (CVarGetInteger("gInvertYAxis", 1) ? 1 : -1);
+
+    if (camera->play->camY > 0x32A4) { //limit angle up
+        camera->play->camY = 0x32A4;
+    }
+    if (camera->play->camY < -0x228C) { //limit angle down
+        camera->play->camY = -0x228C;
+    }
+
+    f32 distTarget = CVarGetInteger("gFreeCameraDistMax", para1->distTarget);
+    f32 speedScaler = CVarGetInteger("gFreeCameraTransitionSpeed", 25);
+    f32 distDiff = ABS(distTarget - camera->dist);
+    if (distDiff > 0)
+        camera->dist = Camera_LERPCeilF(distTarget, camera->dist, speedScaler / (distDiff + speedScaler), 0.0f);
+    OLib_Vec3fDiffToVecSphGeo(&spA8, at, eyeNext);
+
+    spA8.r = camera->dist;
+    spA8.yaw = camera->play->camX;
+    spA8.pitch = camera->play->camY;
+
+    Camera_Vec3fVecSphGeoAdd(eyeNext, at, &spA8);
+    if (camera->status == CAM_STAT_ACTIVE) {
+        sp6C.pos = *eyeNext;
+        Camera_BGCheckInfo(camera, at, &sp6C);
+        *eye = sp6C.pos;
+    }
+
+    camera->fov = Camera_LERPCeilF(65.0f, camera->fov, camera->fovUpdateRate, 1.0f);
+    camera->roll = Camera_LERPCeilS(0, camera->roll, 0.5, 0xA);
+
+    return 1;
+}
+
 s32 Camera_Normal1(Camera* camera) {
     if (CVarGetInteger("gFreeCamera", 0) && SetCameraManual(camera) == 1) {
         Camera_Free(camera);
         return 1;
     }
+    //Third Person Aim
+    if (camera->player->thirdPersonAiming == true) {
+        //Camera_ThirdPersonAim(camera);
+
+        //return 1;
+    }
 
     Vec3f* eye = &camera->eye;
     Vec3f* at = &camera->at;
@@ -2366,22 +2456,26 @@ s32 Camera_Jump1(Camera* camera) {
         camera->xzOffsetUpdateRate = (1.0f / 10000.0f);
         camera->animState++;
     }
+    //CUSTOM camera to follow close to Glider
+    //playerPosRot->pos.y - camera->playerGroundY
+    anim->unk_1C = playerPosRot->pos.y - camera->playerPosDelta.y;
+    camera->posOffset.y -= camera->playerPosDelta.y;
 
     if (anim->swing.swingUpdateRateTimer != 0) {
         camera->yawUpdateRateInv = Camera_LERPCeilF(jump1->yawUpateRateTarget + anim->swing.swingUpdateRateTimer,
-                                                    camera->yawUpdateRateInv, PCT(OREG(26)), 0.1f);
+                                                    camera->yawUpdateRateInv, PCT(OREG(26)) * 4.0f, 0.1f);
         camera->pitchUpdateRateInv = Camera_LERPCeilF((f32)R_CAM_DEFA_PHI_UPDRATE + anim->swing.swingUpdateRateTimer,
-                                                      camera->pitchUpdateRateInv, PCT(OREG(26)), 0.1f);
+                                                      camera->pitchUpdateRateInv, PCT(OREG(26)) * 4.0f, 0.1f);
         anim->swing.swingUpdateRateTimer--;
     } else {
         camera->yawUpdateRateInv =
-            Camera_LERPCeilF(jump1->yawUpateRateTarget, camera->yawUpdateRateInv, PCT(OREG(26)), 0.1f);
+            Camera_LERPCeilF(jump1->yawUpateRateTarget, camera->yawUpdateRateInv, PCT(OREG(26)) * 4.0f, 0.1f);
         camera->pitchUpdateRateInv =
-            Camera_LERPCeilF((f32)R_CAM_DEFA_PHI_UPDRATE, camera->pitchUpdateRateInv, PCT(OREG(26)), 0.1f);
+            Camera_LERPCeilF((f32)R_CAM_DEFA_PHI_UPDRATE, camera->pitchUpdateRateInv, PCT(OREG(26)) * 4.0f, 0.1f);
     }
 
-    camera->xzOffsetUpdateRate = Camera_LERPCeilF(PCT(OREG(2)), camera->xzOffsetUpdateRate, PCT(OREG(25)), 0.1f);
-    camera->yOffsetUpdateRate = Camera_LERPCeilF(PCT(OREG(3)), camera->yOffsetUpdateRate, PCT(OREG(26)), 0.1f);
+    camera->xzOffsetUpdateRate = Camera_LERPCeilF(PCT(OREG(2)), camera->xzOffsetUpdateRate, PCT(OREG(25)) * 4.0f, 0.1f);
+    camera->yOffsetUpdateRate = Camera_LERPCeilF(PCT(OREG(3)), camera->yOffsetUpdateRate, PCT(OREG(26)) * 4.0f, 0.1f);
     camera->fovUpdateRate = Camera_LERPCeilF(PCT(OREG(4)), camera->yOffsetUpdateRate, 0.05f, 0.1f);
 
     func_800458D4(camera, &eyeNextAtOffset, jump1->atYOffset, &anim->unk_1C, 0);
@@ -2391,17 +2485,18 @@ s32 Camera_Jump1(Camera* camera) {
     OLib_Vec3fDiffToVecSphGeo(&eyeDiffTarget, at, eye);
 
     eyeDiffSph.r = Camera_LERPCeilF(eyeDiffTarget.r, eyeAtOffset.r, PCT(OREG(29)), 1.0f);
-    eyeDiffSph.pitch = Camera_LERPCeilS(eyeDiffTarget.pitch, eyeAtOffset.pitch, PCT(OREG(29)), 0xA);
+    eyeDiffSph.pitch = Camera_LERPCeilS(eyeDiffTarget.pitch, eyeAtOffset.pitch, PCT(OREG(29)) * 4.0f, 0xA);
 
     if (anim->swing.unk_18) {
         eyeDiffSph.yaw =
-            Camera_LERPCeilS(anim->swing.unk_16, eyeNextAtOffset.yaw, 1.0f / camera->yawUpdateRateInv, 0xA);
+            Camera_LERPCeilS(anim->swing.unk_16, eyeNextAtOffset.yaw, 4.0f / camera->yawUpdateRateInv, 0xA);
         eyeDiffSph.pitch =
-            Camera_LERPCeilS(anim->swing.unk_14, eyeNextAtOffset.pitch, 1.0f / camera->yawUpdateRateInv, 0xA);
+            Camera_LERPCeilS(anim->swing.unk_14, eyeNextAtOffset.pitch, 4.0f / camera->yawUpdateRateInv, 0xA);
     } else {
         eyeDiffSph.yaw =
             Camera_CalcDefaultYaw(camera, eyeNextAtOffset.yaw, camera->playerPosRot.rot.y, jump1->maxYawUpdate, 0.0f);
     }
+    eyeDiffSph.pitch = anim->swing.unk_14;
 
     // Clamp the eye->at distance to jump1->distMin < eyeDiffSph.r < jump1->distMax
     if (eyeDiffSph.r < jump1->distMin) {
diff --git a/soh/src/code/z_common_data.c b/soh/src/code/z_common_data.c
index 83486b2d..f218d5c2 100644
--- a/soh/src/code/z_common_data.c
+++ b/soh/src/code/z_common_data.c
@@ -16,4 +16,10 @@ void SaveContext_Init(void) {
     gSaveContext.dogIsLost = true;
     gSaveContext.nextTransitionType = 0xFF;
     gSaveContext.unk_13EE = 50;
+    //CUSTOM
+    gSaveContext.inventory.items2[0] = ITEM_JUMP;
+    gSaveContext.inventory.items2[1] = ITEM_GLIDER;
+    gSaveContext.inventory.items2[2] = ITEM_LANTERN;
+    gSaveContext.inventory.items2[3] = ITEM_STASIS;
+    for (int i = 4; i < 24; i++) gSaveContext.inventory.items2[i] = ITEM_NONE;
 }
diff --git a/soh/src/code/z_parameter.c b/soh/src/code/z_parameter.c
index 20debfd7..c4f374d0 100644
--- a/soh/src/code/z_parameter.c
+++ b/soh/src/code/z_parameter.c
@@ -135,7 +135,7 @@ static RestrictionFlags sRestrictionFlags[] = {
     { SCENE_SPIRIT_TEMPLE_BOSS, 0x00, 0x45, 0x50 },
     { SCENE_GANONS_TOWER, 0x00, 0x00, 0x00 },
     { SCENE_GANONDORF_BOSS, 0x00, 0x45, 0x50 },
-    { SCENE_ICE_CAVERN, 0x00, 0x00, 0xC0 },
+    { SCENE_ICE_CAVERN, 0x00, 0x00, 0x10 }, //this? { SCENE_ICE_CAVERN, 0x00, 0x00, 0xC0 }
     { SCENE_WINDMILL_AND_DAMPES_GRAVE, 0x00, 0x03, 0x14 },
     { SCENE_INSIDE_GANONS_CASTLE, 0x00, 0x03, 0x10 },
     { SCENE_GANON_BOSS, 0x00, 0x45, 0x50 },
@@ -3567,6 +3567,36 @@ void Interface_DrawLineupTick(PlayState* play) {
     CLOSE_DISPS(play->state.gfxCtx);
 }
 
+void Interface_DrawCrosshair(PlayState* play) {
+    InterfaceContext* interfaceCtx = &play->interfaceCtx;
+
+    OPEN_DISPS(play->state.gfxCtx);
+
+    Gfx_SetupDL_39Overlay(play->state.gfxCtx);
+
+    gDPSetEnvColor(OVERLAY_DISP++, 255, 255, 255, 255);
+    gDPSetPrimColor(OVERLAY_DISP++, 0, 0, 255, 255, 255, 255);
+
+    s16 width = 32;
+    s16 height = 32;
+    int rotX = GET_PLAYER(play)->runningTorsoForwardRotation;
+    if (rotX <= 0) rotX = 0;
+    float offset = Math_SinF(rotX / 8000.0f);
+    s16 x = (SCREEN_WIDTH / 2) - 4 + offset * 40.0f;
+    s16 y = (SCREEN_HEIGHT / 2) - 4 + offset * 40.0f;
+    int itemAction = GET_PLAYER(play)->heldItemAction;
+    if ((itemAction >= PLAYER_IA_BOW) & (itemAction <= PLAYER_IA_BOW_0E)) {
+        y -= 4;
+    }
+
+
+    OVERLAY_DISP = Gfx_TextureIA8(OVERLAY_DISP, gCrosshairTex, width, height, x, y, width / 2, height / 2, 2 << 10, 2 << 10);
+
+    gDPPipeSync(OVERLAY_DISP++);
+
+    CLOSE_DISPS(play->state.gfxCtx);
+}
+
 void Interface_DrawMagicBar(PlayState* play) {
     InterfaceContext* interfaceCtx = &play->interfaceCtx;
     s16 magicDrop = R_MAGIC_BAR_LARGE_Y-R_MAGIC_BAR_SMALL_Y+2;
@@ -3807,7 +3837,7 @@ void Interface_DrawEnemyHealthBar(TargetContext* targetCtx, PlayState* play) {
         Interface_CreateQuadVertexGroup(&sEnemyHealthVtx[12], -floorf(halfBarWidth) + endTexWidth, (-texHeight / 2) + 3,
                                         healthBarFill, 7, 0);
 
-        if (((!(player->stateFlags1 & 0x40)) || (actor != player->unk_664)) && targetCtx->unk_44 < 500.0f) {
+        if (((!(player->stateFlags1 & 0x40)) || (actor != player->targetActorMaybe)) && targetCtx->unk_44 < 500.0f) {
             f32 slideInOffsetY = 0;
 
             // Slide in the health bar from edge of the screen (mimic the Z-Target triangles fly in)
@@ -5319,6 +5349,7 @@ void Interface_Draw(PlayState* play) {
         if (CVarGetInteger("gDrawLineupTick", 0)) {
             Interface_DrawLineupTick(play);
         }
+        if (GET_PLAYER(play)->thirdPersonAiming) Interface_DrawCrosshair(play);
 
         if (fullUi || gSaveContext.magicState > MAGIC_STATE_IDLE) {
             Interface_DrawMagicBar(play);
diff --git a/soh/src/code/z_player_lib.c b/soh/src/code/z_player_lib.c
index 820f2c67..613f1122 100644
--- a/soh/src/code/z_player_lib.c
+++ b/soh/src/code/z_player_lib.c
@@ -110,8 +110,23 @@ u8 sActionModelGroups[] = {
     PLAYER_MODELGROUP_DEFAULT,       // PLAYER_IA_BOOTS_KOKIRI
     PLAYER_MODELGROUP_DEFAULT,       // PLAYER_IA_BOOTS_IRON
     PLAYER_MODELGROUP_DEFAULT,       // PLAYER_IA_BOOTS_HOVER
+    //CUSTOM
+    PLAYER_MODELGROUP_DEFAULT,        // PLAYER_IA_JUMP
+    PLAYER_MODELGROUP_DEFAULT,        // PLAYER_IA_GLIDER
+    PLAYER_MODELGROUP_LANTERN,        // PLAYER_IA_LANTERN
+    PLAYER_MODELGROUP_BOW_SLINGSHOT,      // PLAYER_IA_STASIS
+
+};
+
+//CUSTOM
+u8 sActionModelGroupsCustom[] = {
+    PLAYER_MODELGROUP_DEFAULT,        // PLAYER_IA_JUMP
+    PLAYER_MODELGROUP_DEFAULT,        // PLAYER_IA_GLIDER
+    PLAYER_MODELGROUP_LANTERN,        // PLAYER_IA_LANTERN
+    PLAYER_MODELGROUP_BOW_SLINGSHOT,      // PLAYER_IA_STASIS
 };
 
+
 TextTriggerEntry sTextTriggers[] = {
     { 1, 0x3040 },
     { 2, 0x401D },
@@ -240,6 +255,14 @@ u8 gPlayerModelTypes[PLAYER_MODELGROUP_MAX][PLAYER_MODELGROUPENTRY_MAX] = {
         PLAYER_MODELTYPE_RH_OPEN,
         PLAYER_MODELTYPE_SHEATH_18,
         PLAYER_MODELTYPE_WAIST
+    },
+            /* PLAYER_MODELGROUP_LANTERN */
+    {
+        PLAYER_ANIMTYPE_0,
+        PLAYER_MODELTYPE_LH_LANTERN,
+        PLAYER_MODELTYPE_RH_OPEN,
+        PLAYER_MODELTYPE_SHEATH_18,
+        PLAYER_MODELTYPE_WAIST
     },
     /* PLAYER_MODELGROUP_15 */
     {
@@ -456,6 +479,13 @@ Gfx* sPlayerLeftHandBottleDLs[] = {
     gLinkChildLeftHandUpNearDL,
 };
 
+Gfx* sPlayerLeftHandLanternDLs[] = {
+    gLinkAdultLeftHandOutNearDL,
+    gLinkChildLeftHandUpNearDL,
+    gLinkAdultLeftHandOutNearDL,
+    gLinkChildLeftHandUpNearDL,
+};
+
 Gfx* sFirstPersonLeftForearmDLs[] = {
     gLinkAdultRightArmOutNearDL,
     NULL,
@@ -491,6 +521,9 @@ Gfx** sPlayerDListGroups[PLAYER_MODELTYPE_MAX] = {
     sPlayerLeftHandHammerDLs,         // PLAYER_MODELTYPE_LH_HAMMER
     gPlayerLeftHandBoomerangDLs,      // PLAYER_MODELTYPE_LH_BOOMERANG
     sPlayerLeftHandBottleDLs,         // PLAYER_MODELTYPE_LH_BOTTLE
+
+    sPlayerLeftHandLanternDLs,         // PLAYER_MODELTYPE_LH_LANTERN
+
     sPlayerRightHandOpenDLs,          // PLAYER_MODELTYPE_RH_OPEN
     sPlayerRightHandClosedDLs,        // PLAYER_MODELTYPE_RH_CLOSED
     sPlayerRightHandShieldDLs,        // PLAYER_MODELTYPE_RH_SHIELD
@@ -584,8 +617,8 @@ s32 Player_InCsMode(PlayState* play) {
     return Player_InBlockingCsMode(play, this) || (this->unk_6AD == 4);
 }
 
-s32 func_8008E9C4(Player* this) {
-    return (this->stateFlags1 & 0x10);
+s32 Is_PLAYER_STATE1_ENEMY_TARGET(Player* this) {
+    return (this->stateFlags1 & PLAYER_STATE1_ENEMY_TARGET);
 }
 
 s32 Player_IsChildWithHylianShield(Player* this) {
@@ -594,6 +627,11 @@ s32 Player_IsChildWithHylianShield(Player* this) {
 
 s32 Player_ActionToModelGroup(Player* this, s32 actionParam) {
     s32 modelGroup = sActionModelGroups[actionParam];
+    
+    //CUSTOM
+    if (actionParam >= PLAYER_IA_JUMP) {
+        modelGroup = sActionModelGroupsCustom[actionParam - PLAYER_IA_JUMP];
+    }
 
     if ((modelGroup == PLAYER_MODELGROUP_SWORD) && Player_IsChildWithHylianShield(this)) {
         // child, using kokiri sword with hylian shield equipped
@@ -690,7 +728,7 @@ void Player_UpdateBottleHeld(PlayState* play, Player* this, s32 item, s32 action
 }
 
 void func_8008EDF0(Player* this) {
-    this->unk_664 = NULL;
+    this->targetActorMaybe = NULL;
     this->stateFlags2 &= ~0x2000;
 }
 
@@ -709,7 +747,7 @@ void func_8008EEAC(PlayState* play, Actor* actor) {
     Player* this = GET_PLAYER(play);
 
     func_8008EE08(this);
-    this->unk_664 = actor;
+    this->targetActorMaybe = actor;
     this->unk_684 = actor;
     this->stateFlags1 |= 0x10000;
     Camera_SetParam(Play_GetCamera(play, 0), 8, actor);
@@ -1233,9 +1271,9 @@ s32 Player_OverrideLimbDrawGameplayCommon(PlayState* play, s32 limbIndex, Gfx**
                     Matrix_Translate((LINK_IS_ADULT ? 3600.0f : 2900.0f) * ABS(scale - 1.0f), 0.0f, 0.0f, MTXMODE_APPLY);
                 }
             }
-            rot->x += this->unk_6BA;
-            rot->y -= this->unk_6B8;
-            rot->z += this->unk_6B6;
+            rot->x += this->runningHeadLeanRotation; //more like Z
+            rot->y -= this->focusHeadYRotation; //Head Y Rotation
+            rot->z += this->runningHeadForwardRotation; //more like X
         } else if (limbIndex == PLAYER_LIMB_L_HAND) {
             if (CVarGetInteger("gCosmetics.Link_SwordScale.Changed", 0)) {
                 f32 scale = CVarGetFloat("gCosmetics.Link_SwordScale.Value", 1.0f);
@@ -1250,11 +1288,11 @@ s32 Player_OverrideLimbDrawGameplayCommon(PlayState* play, s32 limbIndex, Gfx**
             if (this->unk_6BE != 0) {
                 Matrix_RotateY(this->unk_6BE * (M_PI / 0x8000), MTXMODE_APPLY);
             }
-            if (this->unk_6BC != 0) {
-                Matrix_RotateX(this->unk_6BC * (M_PI / 0x8000), MTXMODE_APPLY);
+            if (this->runningTorsoForwardRotation != 0) {
+                Matrix_RotateX(this->runningTorsoForwardRotation * (M_PI / 0x8000), MTXMODE_APPLY);
             }
-            if (this->unk_6C0 != 0) {
-                Matrix_RotateZ(this->unk_6C0 * (M_PI / 0x8000), MTXMODE_APPLY);
+            if (this->readyToFireTorsoRotZ != 0) {
+                Matrix_RotateZ(this->readyToFireTorsoRotZ * (M_PI / 0x8000), MTXMODE_APPLY);
             }
         } else if (limbIndex == PLAYER_LIMB_L_THIGH) {
             func_8008F87C(play, this, &this->skelAnime, pos, rot, PLAYER_LIMB_L_THIGH, PLAYER_LIMB_L_SHIN,
@@ -1610,6 +1648,57 @@ void Player_DrawHookshotReticle(PlayState* play, Player* this, f32 hookshotRange
     }
 }
 
+void Player_DrawThirdPersonReticle(PlayState* play, Player* this, f32 hookshotRange) {
+    CollisionPoly* colPoly;
+    s32 bgId;
+    Vec3f firstHit;
+    Vec3f sp68;
+    f32 sp64;
+
+    Vec3f PlayerPos = this->actor.world.pos;
+    PlayerPos.y += 10.0f;
+    Vec3f AimPos = Play_GetCamera(play, 0)->eye;
+    AimPos.z += 10000.0f * Math_CosS(Play_GetCamera(play, 0)->camDir.y);
+    AimPos.x += 10000.0f * Math_SinS(Play_GetCamera(play, 0)->camDir.y);
+    AimPos.y += 10000.0f * Math_SinS(Play_GetCamera(play, 0)->camDir.x);
+
+    if (BgCheck_AnyLineTest3(&play->colCtx, &PlayerPos, &AimPos, &firstHit, &colPoly, 1, 1, 1, 1, &bgId)) {
+        OPEN_DISPS(play->state.gfxCtx);
+
+        WORLD_OVERLAY_DISP = Gfx_SetupDL(WORLD_OVERLAY_DISP, 0x07);
+
+        SkinMatrix_Vec3fMtxFMultXYZW(&play->viewProjectionMtxF, &firstHit, &sp68, &sp64);
+
+        const f32 sp60 = (sp64 < 200.0f) ? 0.08f : (sp64 / 200.0f) * 0.08f;
+
+        Matrix_Translate(firstHit.x, firstHit.y, firstHit.z, MTXMODE_NEW);
+        Matrix_Scale(sp60, sp60, sp60, MTXMODE_APPLY);
+
+        gSPMatrix(WORLD_OVERLAY_DISP++, MATRIX_NEWMTX(play->state.gfxCtx), G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
+        gSPMatrix(WORLD_OVERLAY_DISP++, SEG_ADDR(1, 0), G_MTX_NOPUSH | G_MTX_MUL | G_MTX_MODELVIEW);
+        gSPTexture(WORLD_OVERLAY_DISP++, 0xFFFF, 0xFFFF, 0, G_TX_RENDERTILE, G_ON);
+        gDPLoadTextureBlock(WORLD_OVERLAY_DISP++, gLinkAdultHookshotReticleTex, G_IM_FMT_I, G_IM_SIZ_8b, 64, 64, 0,
+            G_TX_NOMIRROR | G_TX_CLAMP, G_TX_NOMIRROR | G_TX_CLAMP, 6, 6, G_TX_NOLOD, G_TX_NOLOD);
+        if (SurfaceType_IsHookshotSurface(&play->colCtx, colPoly, bgId) && CVarGetInteger("gHookshotableReticle", false)) {
+            const Color_RGBA8 defaultColor = { .r = 0, .g = 255, .b = 0, .a = 255 };
+            const Color_RGBA8 color = CVarGetColor("gCosmetics.HookshotReticle_Target.Value", defaultColor);
+            gDPSetPrimColor(WORLD_OVERLAY_DISP++, 0, 0, color.r, color.g, color.b, color.a);
+        }
+        else {
+            const Color_RGBA8 defaultColor = { .r = 255, .g = 0, .b = 0, .a = 255 };
+            const Color_RGBA8 color = CVarGetColor("gCosmetics.HookshotReticle_NonTarget.Value", defaultColor);
+            gDPSetPrimColor(WORLD_OVERLAY_DISP++, 0, 0, color.r, color.g, color.b, color.a);
+        }
+        gSPVertex(WORLD_OVERLAY_DISP++, (uintptr_t)gLinkAdultHookshotReticleVtx, 3, 0);
+        gSP1Triangle(WORLD_OVERLAY_DISP++, 0, 1, 2, 0);
+
+        CLOSE_DISPS(play->state.gfxCtx);
+    }
+}
+
+
+
+
 Vec3f D_801260D4 = { 1100.0f, -700.0f, 0.0f };
 
 f32 sMeleeWeaponLengths[] = {
@@ -1678,6 +1767,10 @@ void Player_PostLimbDrawGameplay(PlayState* play, s32 limbIndex, Gfx** dList, Ve
 
         Math_Vec3f_Copy(&this->leftHandPos, D_80160000);
 
+        if (this->itemAction == PLAYER_IA_LANTERN) {
+            Gfx_DrawDListOpa(play, gLanternDL);
+        }
+
         if (this->itemAction == PLAYER_IA_DEKU_STICK) {
             Vec3f sp124[3];
 
@@ -1814,6 +1907,7 @@ void Player_PostLimbDrawGameplay(PlayState* play, s32 limbIndex, Gfx** dList, Ve
                 Matrix_MultVec3f(&D_80126184, &this->unk_3C8);
 
                 if (heldActor != NULL) {
+ 
                     MtxF sp44;
                     s32 pad;
 
@@ -1829,12 +1923,14 @@ void Player_PostLimbDrawGameplay(PlayState* play, s32 limbIndex, Gfx** dList, Ve
                             play, this, ((this->heldItemAction == PLAYER_IA_HOOKSHOT) ? 38600.0f : 77600.0f) * CVarGetFloat("gCheatHookshotReachMultiplier", 1.0f));
                     }
                 }
-            } else if (CVarGetInteger("gBowReticle", 0) && (
+            }
+            else if (CVarGetInteger("gBowReticle", 0) && (
                         (this->heldItemAction == PLAYER_IA_BOW_FIRE) ||
                         (this->heldItemAction == PLAYER_IA_BOW_ICE) ||
                         (this->heldItemAction == PLAYER_IA_BOW_LIGHT) ||
                         (this->heldItemAction == PLAYER_IA_BOW) ||
-                        (this->heldItemAction == PLAYER_IA_SLINGSHOT))) {
+                        (this->heldItemAction == PLAYER_IA_SLINGSHOT) ||
+                        (this->heldItemAction == PLAYER_IA_STASIS))) { //CUSTOM
                 if (heldActor != NULL) {
                     MtxF sp44;
                     s32 pad;
@@ -1849,7 +1945,7 @@ void Player_PostLimbDrawGameplay(PlayState* play, s32 limbIndex, Gfx** dList, Ve
                 }
             }
 
-            if ((this->unk_862 != 0) || ((func_8002DD6C(this) == 0) && (heldActor != NULL))) {
+            if ((this->unk_862 != 0) || ((PlayerStateItemInHand(this) == 0) && (heldActor != NULL))) {
                 if (!(this->stateFlags1 & 0x400) && (this->unk_862 != 0) && (this->exchangeItemId != EXCH_ITEM_NONE)) {
                     Math_Vec3f_Copy(&sGetItemRefPos, &this->leftHandPos);
                 } else {
diff --git a/soh/src/overlays/actors/ovl_Bg_Ice_Shelter/z_bg_ice_shelter.c b/soh/src/overlays/actors/ovl_Bg_Ice_Shelter/z_bg_ice_shelter.c
index 36666ed1..c58aa27b 100644
--- a/soh/src/overlays/actors/ovl_Bg_Ice_Shelter/z_bg_ice_shelter.c
+++ b/soh/src/overlays/actors/ovl_Bg_Ice_Shelter/z_bg_ice_shelter.c
@@ -1,4 +1,4 @@
-#include "z_bg_ice_shelter.h"
+    #include "z_bg_ice_shelter.h"
 #include "objects/object_ice_objects/object_ice_objects.h"
 
 #define FLAGS 0
@@ -16,6 +16,7 @@ void func_808911D4(BgIceShelter* this, PlayState* play);
 
 // For "Blue Fire Arrows" enhancement
 void MeltOnIceArrowHit(BgIceShelter* this, ColliderCylinder cylinder, s16 type, PlayState* play);
+void MeltOnLanternBlueFire(BgIceShelter* this, ColliderCylinder cylinder, s16 type, PlayState* play);
 
 const ActorInit Bg_Ice_Shelter_InitVars = {
     ACTOR_BG_ICE_SHELTER,
@@ -331,6 +332,10 @@ void func_8089107C(BgIceShelter* this, PlayState* play) {
         MeltOnIceArrowHit(this, this->cylinder1, type, play);
         MeltOnIceArrowHit(this, this->cylinder2, type, play);
     }
+    //Melt from Lantern Blue Fire
+    MeltOnLanternBlueFire(this, this->cylinder1, type, play);
+    MeltOnLanternBlueFire(this, this->cylinder2, type, play);
+
     // Default blue fire check
     if (this->cylinder1.base.acFlags & AC_HIT) {
         this->cylinder1.base.acFlags &= ~AC_HIT;
@@ -377,6 +382,23 @@ void MeltOnIceArrowHit(BgIceShelter* this, ColliderCylinder cylinder, s16 type,
     }
 }
 
+void MeltOnLanternBlueFire(BgIceShelter* this, ColliderCylinder cylinder, s16 type, PlayState* play) {
+    if (cylinder.base.acFlags & AC_HIT) {
+        cylinder.base.acFlags &= ~AC_HIT;
+        if ((cylinder.base.ac != NULL) && (cylinder.base.ac->id == ACTOR_LANTERN_FIRE)) {
+            if (cylinder.base.ac->params == 1) { // is Blue Fire
+                if (type == 4) {
+                    if (this->dyna.actor.parent != NULL) {
+                        this->dyna.actor.parent->freezeTimer = 50;
+                    }
+                }
+                func_808911BC(this);
+                Audio_PlayActorSound2(&this->dyna.actor, NA_SE_EV_ICE_MELT);
+            }
+        }
+    }
+}
+
 void func_808911BC(BgIceShelter* this) {
     this->actionFunc = func_808911D4;
     this->alpha = 255;
diff --git a/soh/src/overlays/actors/ovl_Custom_Projectile/z_custom_projectile.c b/soh/src/overlays/actors/ovl_Custom_Projectile/z_custom_projectile.c
new file mode 100644
index 00000000..34f6fe8c
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_Custom_Projectile/z_custom_projectile.c
@@ -0,0 +1,323 @@
+/*
+ * File: z_custom_projectiles.c
+ * Overlay: ovl_Custom_Projectile
+ * Description: Arrow, Deku Seed, and Deku Nut Projectile
+ */
+
+#include "z_custom_projectile.h"
+#include "objects/gameplay_keep/gameplay_keep.h"
+
+#define FLAGS (ACTOR_FLAG_UPDATE_WHILE_CULLED | ACTOR_FLAG_DRAW_WHILE_CULLED)
+
+void CustomProjectile_Init(Actor* thisx, PlayState* play);
+void CustomProjectile_Destroy(Actor* thisx, PlayState* play);
+void CustomProjectile_Update(Actor* thisx, PlayState* play);
+void CustomProjectile_Draw(Actor* thisx, PlayState* play);
+
+void CustomProjectile_Shoot(CustomProjectile* this, PlayState* play);
+void CustomProjectile_Fly(CustomProjectile* this, PlayState* play);
+void CustomProjectile_func_809B45E0(CustomProjectile* this, PlayState* play);
+void CustomProjectile_func_809B4640(CustomProjectile* this, PlayState* play);
+
+const ActorInit Custom_Projectile_InitVars = {
+    ACTOR_CUSTOM_PROJECTILE,
+    ACTORCAT_ITEMACTION,
+    FLAGS,
+    OBJECT_GAMEPLAY_KEEP,
+    sizeof(CustomProjectile),
+    (ActorFunc)CustomProjectile_Init,
+    (ActorFunc)CustomProjectile_Destroy,
+    (ActorFunc)CustomProjectile_Update,
+    (ActorFunc)CustomProjectile_Draw,
+    NULL,
+};
+
+static ColliderQuadInit sColliderInit = {
+    {
+        COLTYPE_NONE,
+        AT_ON | AT_TYPE_ALL,
+        AC_NONE,
+        OC1_NONE,
+        OC2_NONE,
+        COLSHAPE_QUAD,
+    },
+    {
+        ELEMTYPE_UNK0,
+        { 0x000001B7, 0x00, 0x00 },
+        { 0xFFFFFFFF, 0xFF, 0xFF },
+        TOUCH_ON | TOUCH_NEAREST | TOUCH_SFX_NONE,
+        BUMP_NONE,
+        OCELEM_NONE,
+    },
+    { { { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f }, { 0.0f, 0.0f, 0.0f } } },
+};
+
+static InitChainEntry sInitChain[] = {
+    ICHAIN_F32(minVelocityY, -150, ICHAIN_STOP),
+};
+
+void CustomProjectile_SetupAction(CustomProjectile* this, CustomProjectileActionFunc actionFunc) {
+    this->actionFunc = actionFunc;
+}
+
+void CustomProjectile_Init(Actor* thisx, PlayState* play) {
+    thisx->room = -1;
+    static u32 dmgFlags[] = {
+        0x00000800, 0x00000020, 0x00000020, 0x00000800, 0x00001000,
+        0x00002000, 0x00010000, 0x00004000, 0x00008000, 0x00000004,
+    };
+    CustomProjectile* this = (CustomProjectile*)thisx;
+    Actor_ProcessInitChain(&this->actor, sInitChain);
+    SkelAnime_Init(play, &this->skelAnime, &gArrowSkel, &gArrow2Anim, NULL, NULL, 0);
+        
+    Collider_InitQuad(play, &this->collider);
+    Collider_SetQuad(play, &this->collider, &this->actor, &sColliderInit);
+
+    if (this->actor.params <= PROJECTILE_NORMAL) {
+        //this->collider.info.toucherFlags &= ~0x18;
+        //this->collider.info.toucherFlags |= 0;
+    }
+    //this->collider.info.toucher.dmgFlags = dmgFlags[this->actor.params];
+    CustomProjectile_SetupAction(this, CustomProjectile_Shoot);
+}
+
+void CustomProjectile_Destroy(Actor* thisx, PlayState* play) {
+    CustomProjectile* this = (CustomProjectile*)thisx;
+    SkelAnime_Free(&this->skelAnime, play);
+    Collider_DestroyQuad(play, &this->collider);
+}
+
+void CustomProjectile_Shoot(CustomProjectile* this, PlayState* play) {
+    Player* player = GET_PLAYER(play);
+
+    if (this->actor.parent == NULL) {
+
+        switch (this->actor.params) {
+            case PROJECTILE_SEED:
+                Player_PlaySfx(&player->actor, NA_SE_IT_SLING_SHOT);
+                break;
+
+            case PROJECTILE_NORMAL_LIT:
+            case PROJECTILE_NORMAL_HORSE:
+            case PROJECTILE_NORMAL:
+                Player_PlaySfx(&player->actor, NA_SE_IT_ARROW_SHOT);
+                break;
+
+            case PROJECTILE_FIRE:
+            case PROJECTILE_ICE:
+            case PROJECTILE_LIGHT:
+                Player_PlaySfx(&player->actor, NA_SE_IT_MAGIC_ARROW_SHOT);
+                break;
+        }
+        CustomProjectile_SetupAction(this, CustomProjectile_Fly);
+        Math_Vec3f_Copy(&this->unk_210, &this->actor.world.pos);
+        func_8002D9A4(&this->actor, 150.0f); //set speed at launch
+        this->timer = 12;
+    }
+}
+
+
+void CustomProjectile_Fly(CustomProjectile* this, PlayState* play) {
+    CollisionPoly* hitPoly;
+    s32 bgId;
+    Vec3f hitPoint;
+    Vec3f posCopy;
+    s32 atTouched;
+    u16 sfxId;
+    Actor* hitActor;
+    Vec3f sp60;
+    Vec3f sp54;
+
+    DynaPolyActor* dynaPolyActor;
+
+    if (this->stasisActor == NULL) {
+        if (DECR(this->timer) == 0) {
+            Actor_Kill(&this->actor);
+            return;
+        }
+
+        if (this->timer < 7.2000003f) {
+            this->actor.gravity = -0.4f;
+        }
+
+        atTouched = (this->collider.base.atFlags & AT_HIT);
+
+        Math_Vec3f_Copy(&this->unk_210, &this->actor.world.pos);
+        Actor_MoveForward(&this->actor);
+        this->touchedPoly = BgCheck_ProjectileLineTest(&play->colCtx, &this->actor.prevPos, &this->actor.world.pos, &hitPoint, &this->actor.wallPoly, true, true, true, true, &bgId);
+        if (this->touchedPoly != 0) {
+
+            dynaPolyActor = DynaPoly_GetActor(&play->colCtx, bgId);
+            if (dynaPolyActor != NULL) {
+                this->stasisActor = &dynaPolyActor->actor;
+            }
+
+
+            func_8002F9EC(play, &this->actor, this->actor.wallPoly, bgId, &hitPoint);
+            Math_Vec3f_Copy(&posCopy, &this->actor.world.pos);
+            Math_Vec3f_Copy(&this->actor.world.pos, &hitPoint);
+        }
+        this->actor.shape.rot.x = Math_Atan2S(this->actor.speedXZ, -this->actor.velocity.y); //point arrow in the direction it is moving
+
+        if (this->hitActor != NULL) {
+            if (this->hitActor->update != NULL) {
+                Math_Vec3f_Sum(&this->unk_210, &this->unk_250, &sp60);
+                Math_Vec3f_Sum(&this->actor.world.pos, &this->unk_250, &sp54);
+
+                if (BgCheck_EntityLineTest1(&play->colCtx, &sp60, &sp54, &hitPoint, &hitPoly, true, true, true, true,
+                    &bgId)) {
+                    this->hitActor->world.pos.x = hitPoint.x + ((sp54.x <= hitPoint.x) ? 1.0f : -1.0f);
+                    this->hitActor->world.pos.y = hitPoint.y + ((sp54.y <= hitPoint.y) ? 1.0f : -1.0f);
+                    this->hitActor->world.pos.z = hitPoint.z + ((sp54.z <= hitPoint.z) ? 1.0f : -1.0f);
+                    Math_Vec3f_Diff(&this->hitActor->world.pos, &this->actor.world.pos, &this->unk_250);
+                    this->hitActor->flags &= ~ACTOR_FLAG_DRAGGED_BY_ARROW;
+                    this->hitActor = NULL;
+                }
+                else {
+                    Math_Vec3f_Sum(&this->actor.world.pos, &this->unk_250, &this->hitActor->world.pos);
+                }
+
+                if (this->touchedPoly && (this->hitActor != NULL)) {
+                    this->hitActor->flags &= ~ACTOR_FLAG_DRAGGED_BY_ARROW;
+                    this->hitActor = NULL;
+                }
+            }
+            else {
+                this->hitActor = NULL;
+            }
+        }
+
+        if (atTouched) {
+            if (this->madeFirstContact == false) {
+                hitActor = this->collider.base.at; //AC or OC???
+                this->stasisActor = hitActor;
+                this->madeFirstContact = true;
+                this->stasisOriginalGravity = this->stasisActor->gravity;
+                this->stasisActor->room = -1;
+            }
+        }
+    }
+    else { //if (this->stasisActor != NULL)
+        if ((this->stasisActor->update != NULL) & (true)) { //this->stasisActor->isDrawn
+            Player* player = GET_PLAYER(play);
+            if ((player->heldItemAction == PLAYER_IA_STASIS) & !(this->actor.flags & 1)) {
+                if (this->stasisReleased == false) {
+                    f32 posX = (Math_SinS(player->actor.focus.rot.y) * 250.0f) + player->actor.world.pos.x;
+                    f32 posZ = (Math_CosS(player->actor.focus.rot.y) * 250.0f) + player->actor.world.pos.z;
+                    f32 posY = (Math_SinS(player->actor.focus.rot.x - 2000) * -250.0f) + player->actor.world.pos.y;
+                    Vec3f old = this->stasisActor->world.pos;
+                    Vec3f new = (Vec3f){ posX, posY, posZ };
+                
+                    float oldWeight = 0.80f;
+                    float newWeight = 1.0f - oldWeight;
+                    this->stasisActor->world.pos = (Vec3f){ (old.x * oldWeight) + (new.x * newWeight) - this->stasisActor->colChkInfo.displacement.x,
+                                                            (old.y * oldWeight) + (new.y * newWeight) - this->stasisActor->colChkInfo.displacement.y,
+                                                            (old.z * oldWeight) + (new.z * newWeight) - this->stasisActor->colChkInfo.displacement.z };
+
+                    Actor_UpdateBgCheckInfo(play, this->stasisActor, 0.0f, 0.0f, 0.0f, 4);
+                    if (this->stasisActor->bgCheckFlags & 1) this->stasisActor->world.pos.y += 1.0f;
+                    //Actor_SetColorFilter(this->stasisActor, -0x8000, 0x78, 0, 10);
+                    this->stasisActor->colorFilterParams = 0x0001;
+                    this->stasisActor->colorFilterTimer = 10;
+                }
+            }
+            else {
+                this->stasisReleased = true;
+            }
+            if (this->stasisReleased) {
+                this->stasisActor->gravity = -0.5f;
+                Actor_MoveForward(this->stasisActor);
+
+                Actor_UpdateBgCheckInfo(play, this->stasisActor, 0.0f, 0.0f, 0.0f, 4);
+                if (this->stasisActor->bgCheckFlags & 1) this->stasisGrounded = true;
+            }
+            if ((this->stasisGrounded) | (player->actor.world.pos.y - this->stasisActor->world.pos.y >= 250.0f)) {
+                this->stasisActor->velocity.y = 0.0f;
+                this->stasisActor->gravity = this->stasisOriginalGravity;
+                this->stasisActor == NULL;
+                this->hitActor == NULL;
+                Actor_Kill(&this->actor);
+                return;
+            }
+        }
+        else {
+            this->stasisActor == NULL;
+            this->hitActor == NULL;
+            Actor_Kill(&this->actor);
+            return;
+        }
+    }
+}
+
+void CustomProjectile_Update(Actor* thisx, PlayState* play) {
+    s32 pad;
+    CustomProjectile* this = (CustomProjectile*)thisx;
+    Player* player = GET_PLAYER(play);
+
+    this->actionFunc(this, play);
+}
+
+void CustomProjectile_func_809B4800(CustomProjectile* this, PlayState* play) {
+    static Vec3f D_809B4E88 = { 0.0f, 400.0f, 1500.0f };
+    static Vec3f D_809B4E94 = { 0.0f, -400.0f, 1500.0f };
+    static Vec3f D_809B4EA0 = { 0.0f, 0.0f, -300.0f };
+    Vec3f sp44;
+    Vec3f sp38;
+    s32 addBlureVertex;
+
+    Matrix_MultVec3f(&D_809B4EA0, &this->unk_21C);
+
+    if (CustomProjectile_Fly == this->actionFunc) {
+        Matrix_MultVec3f(&D_809B4E88, &sp44);
+        Matrix_MultVec3f(&D_809B4E94, &sp38);
+
+        if (this->hitActor == NULL) {
+            addBlureVertex &= func_80090480(play, &this->collider, &this->weaponInfo, &sp44, &sp38);
+        }
+    }
+}
+
+void CustomProjectile_Draw(Actor* thisx, PlayState* play) {
+    s32 pad;
+    CustomProjectile* this = (CustomProjectile*)thisx;
+    u8 alpha;
+    f32 scale;
+
+    if (this->actor.params <= PROJECTILE_0E) {
+        Gfx_SetupDL_25Opa(play->state.gfxCtx);
+        SkelAnime_DrawLod(play, this->skelAnime.skeleton, this->skelAnime.jointTable, NULL, NULL, this,
+                          (this->actor.projectedPos.z < MREG(95)) ? 0 : 1);
+    } else if (this->actor.speedXZ != 0.0f) {
+        alpha = (Math_CosS(this->timer * 5000) * 127.5f) + 127.5f;
+
+        OPEN_DISPS(play->state.gfxCtx);
+
+        Gfx_SetupDL_25Xlu2(play->state.gfxCtx);
+
+        if (this->actor.params == PROJECTILE_SEED) {
+            gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 255, 255, 255, 255);
+            gDPSetEnvColor(POLY_XLU_DISP++, 0, 255, 255, alpha);
+            scale = 50.0f;
+        } else {
+            gDPSetPrimColor(POLY_XLU_DISP++, 0, 0, 12, 0, 0, 255);
+            gDPSetEnvColor(POLY_XLU_DISP++, 250, 250, 0, alpha);
+            scale = 150.0f;
+        }
+
+        Matrix_Push();
+        Matrix_Mult(&play->billboardMtxF, MTXMODE_APPLY);
+        // redundant check because this is contained in an if block for non-zero speed
+        Matrix_RotateZ(
+            (this->actor.speedXZ == 0.0f) ? 0.0f : ((play->gameplayFrames & 0xFF) * 4000) * (M_PI / 0x8000),
+            MTXMODE_APPLY);
+        Matrix_Scale(scale, scale, scale, MTXMODE_APPLY);
+        gSPMatrix(POLY_XLU_DISP++, MATRIX_NEWMTX(play->state.gfxCtx),
+                    G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
+        gSPDisplayList(POLY_XLU_DISP++, gEffSparklesDL);
+        Matrix_Pop();
+        Matrix_RotateY(this->actor.world.rot.y * (M_PI / 0x8000), MTXMODE_APPLY);
+        CLOSE_DISPS(play->state.gfxCtx);
+    }
+
+    CustomProjectile_func_809B4800(this, play); //WHY IS THIS PART OF DRAW?
+}
diff --git a/soh/src/overlays/actors/ovl_Custom_Projectile/z_custom_projectile.h b/soh/src/overlays/actors/ovl_Custom_Projectile/z_custom_projectile.h
new file mode 100644
index 00000000..b83ca004
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_Custom_Projectile/z_custom_projectile.h
@@ -0,0 +1,49 @@
+#ifndef Z_CUSTOM_PROJECTILE_H
+#define Z_CUSTOM_PROJECTILE_H
+
+#include <libultraship/libultra.h>
+#include "global.h"
+
+struct CustomProjectile;
+
+typedef void (*CustomProjectileActionFunc)(struct CustomProjectile*, PlayState*);
+
+typedef struct CustomProjectile {
+    /* 0x0000 */ Actor actor;
+    /* 0x014C */ SkelAnime skelAnime;
+    /* 0x0190 */ ColliderQuad collider;
+    /* 0x0210 */ Vec3f unk_210;
+    /* 0x021C */ Vec3f unk_21C;
+    /* 0x0228 */ s32 effectIndex;
+    /* 0x022C */ WeaponInfo weaponInfo;
+    /* 0x0248 */ u8 timer; // used for dissapearing when flying or hitting a wall
+    /* 0x0249 */ u8 hitFlags;
+    /* 0x024A */ u8 touchedPoly;
+    /* 0x024B */ u8 isCsNut;
+    /* 0x024C */ Actor* hitActor;
+    /* 0x0250 */ Vec3f unk_250;
+    /* 0x025C */ CustomProjectileActionFunc actionFunc;
+    bool madeFirstContact;
+    Actor* stasisActor;
+    bool stasisReleased;
+    bool stasisGrounded;
+    float stasisOriginalGravity;
+} CustomProjectile; // size = 0x0260
+
+typedef enum {
+    /* -10 */ PROJECTILE_CS_NUT = -10, // cutscene deku nuts are allowed to update in blocking mode
+    /* -1  */ PROJECTILE_NORMAL_SILENT = -1, // normal arrow that does not make a sound when being shot
+    /*  0  */ PROJECTILE_NORMAL_LIT, // normal arrow lit on fire
+    /*  1  */ PROJECTILE_NORMAL_HORSE, // normal arrow shot while riding a horse
+    /*  2  */ PROJECTILE_NORMAL,
+    /*  3  */ PROJECTILE_FIRE,
+    /*  4  */ PROJECTILE_ICE,
+    /*  5  */ PROJECTILE_LIGHT,
+    /*  6  */ PROJECTILE_0C,
+    /*  7  */ PROJECTILE_0D,
+    /*  8  */ PROJECTILE_0E,
+    /*  9  */ PROJECTILE_SEED,
+    /*  10 */ PROJECTILE_NUT
+} ProjectileType;
+
+#endif
diff --git a/soh/src/overlays/actors/ovl_En_Elf/z_en_elf.c b/soh/src/overlays/actors/ovl_En_Elf/z_en_elf.c
index 2191daea..05b7d654 100644
--- a/soh/src/overlays/actors/ovl_En_Elf/z_en_elf.c
+++ b/soh/src/overlays/actors/ovl_En_Elf/z_en_elf.c
@@ -1047,11 +1047,11 @@ void func_80A04414(EnElf* this, PlayState* play) {
     }
 
     if (this->fairyFlags & 1) {
-        if ((arrowPointedActor == NULL) || (player->unk_664 == NULL)) {
+        if ((arrowPointedActor == NULL) || (player->targetActorMaybe == NULL)) {
             this->fairyFlags ^= 1;
         }
     } else {
-        if ((arrowPointedActor != NULL) && (player->unk_664 != NULL)) {
+        if ((arrowPointedActor != NULL) && (player->targetActorMaybe != NULL)) {
             if (arrowPointedActor->category == ACTORCAT_NPC) {
                 targetSound = NA_SE_VO_NAVY_HELLO;
             } else {
@@ -1232,7 +1232,7 @@ void func_80A04DE4(EnElf* this, PlayState* play) {
     if (this->fairyFlags & 0x10) {
         naviRefPos = play->actorCtx.targetCtx.naviRefPos;
 
-        if ((player->unk_664 == NULL) || (&player->actor == player->unk_664) || (&this->actor == player->unk_664)) {
+        if ((player->targetActorMaybe == NULL) || (&player->actor == player->targetActorMaybe) || (&this->actor == player->targetActorMaybe)) {
             naviRefPos.x = player->bodyPartsPos[7].x + (Math_SinS(player->actor.shape.rot.y) * 20.0f);
             naviRefPos.y = player->bodyPartsPos[7].y + 5.0f;
             naviRefPos.z = player->bodyPartsPos[7].z + (Math_CosS(player->actor.shape.rot.y) * 20.0f);
@@ -1384,7 +1384,7 @@ void func_80A053F0(Actor* thisx, PlayState* play) {
     EnElf* this = (EnElf*)thisx;
 
     if (player->naviTextId == 0) {
-        if (player->unk_664 == NULL) {
+        if (player->targetActorMaybe == NULL) {
             if (((gSaveContext.naviTimer >= 600) && (gSaveContext.naviTimer <= 3000)) || (nREG(89) != 0)) {
                 player->naviTextId = ElfMessage_GetCUpText(play);
 
diff --git a/soh/src/overlays/actors/ovl_En_Glider/z_en_glider.c b/soh/src/overlays/actors/ovl_En_Glider/z_en_glider.c
new file mode 100644
index 00000000..e8143019
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_En_Glider/z_en_glider.c
@@ -0,0 +1,139 @@
+﻿/*
+ * File: z_En_Glider.c
+ * Overlay: ovl_En_Glider
+ * Description: Glider
+ */
+
+#include "z_en_glider.h"
+#include "objects/gameplay_field_keep/gameplay_field_keep.h"
+#include "vt.h"
+#include "soh/frame_interpolation.h"
+
+#define FLAGS (ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_HOSTILE | ACTOR_FLAG_UPDATE_WHILE_CULLED)
+
+void EnGlider_Init(Actor* thisx, PlayState* play);
+void EnGlider_Destroy(Actor* thisx, PlayState* play);
+void EnGlider_Update(Actor* thisx, PlayState* play);
+void EnGlider_Draw(Actor* thisx, PlayState* play);
+void EnGlider_ResetAction(EnGlider* this, PlayState* play);
+
+const ActorInit En_Glider_InitVars = {
+    ACTOR_EN_GLIDER,
+    ACTORCAT_PROP,
+    FLAGS,
+    OBJECT_GLIDER,
+    sizeof(EnGlider),
+    (ActorFunc)EnGlider_Init,
+    (ActorFunc)EnGlider_Destroy,
+    (ActorFunc)EnGlider_Update,
+    (ActorFunc)EnGlider_Draw,
+};
+
+static ColliderCylinderInit sCylinderInit = { //damages enemies
+    {
+        COLTYPE_NONE,
+        AT_ON | AT_TYPE_PLAYER,
+        AC_NONE,
+        OC1_NONE,
+        OC2_TYPE_PLAYER,
+        COLSHAPE_CYLINDER,
+    },
+    {
+        ELEMTYPE_UNK2,
+        { 0x00100000, 0x00, 0x00 }, //Glider damage type - only collides with wind zones 0x00100000
+        { 0xFFCFFFFF, 0x00, 0x00 },
+        TOUCH_ON | TOUCH_NEAREST | TOUCH_SFX_NONE,
+        BUMP_NONE,
+        OCELEM_NONE,
+    },
+    { 23, 46, 0, { 0, 0, 0 } },
+};
+
+static CollisionCheckInfoInit2 sColChkInit = { 1, 0, 0, 0, MASS_IMMOVABLE };
+
+static InitChainEntry sInitChain[] = {
+    ICHAIN_U8(targetMode, 6, ICHAIN_CONTINUE),
+    ICHAIN_F32_DIV1000(gravity, -2000, ICHAIN_CONTINUE),
+    ICHAIN_F32(targetArrowOffset, 0, ICHAIN_STOP),
+};
+
+s32 EnGlider_CheckCollider(EnGlider* this, PlayState* play) {
+    if (this->collider.base.acFlags & AC_HIT) {
+        this->collider.base.acFlags &= ~AC_HIT;
+        return true;
+    }
+
+    if (this->collider.base.ocFlags2 & OC2_HIT_PLAYER) {
+        this->collider.base.ocFlags2 &= ~OC2_HIT_PLAYER;
+        return true;
+    }
+    return false;
+}
+
+void EnGlider_Init(Actor* thisx, PlayState* play) {
+    EnGlider* this = (EnGlider*)thisx;
+    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 25.0f);
+    Collider_InitCylinder(play, &this->collider);
+    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);
+    Actor_ProcessInitChain(&this->actor, sInitChain);
+    this->actor.flags &= ~ACTOR_FLAG_TARGETABLE;
+    Actor_SetScale(&this->actor, 1.0f);
+    this->actionFunc = EnGlider_ResetAction;
+}
+
+void EnGlider_Destroy(Actor* thisx, PlayState* play) {
+    EnGlider* this = (EnGlider*)thisx;
+    Collider_DestroyCylinder(play, &this->collider);
+    ResourceMgr_UnregisterSkeleton(&this->skelAnime);
+}
+
+void EnGlider_ResetAction(EnGlider* this, PlayState* play) {
+}
+
+void EnGlider_Update(Actor* thisx, PlayState* play) {
+
+    EnGlider* this = (EnGlider*)thisx;
+    Player* player = GET_PLAYER(play);
+    s32 atTouched;
+    Actor* hitActor;
+
+    EnGlider_CheckCollider(this, play);
+
+    this->actionFunc(this, play);
+    Actor_SetFocus(&this->actor, this->unk_304);
+    Actor_MoveForward(&this->actor);
+
+
+
+    atTouched = (this->collider.base.atFlags & AT_HIT);
+    if (atTouched && (this->collider.info.atHitInfo->elemType != ELEMTYPE_UNK4)) {
+        hitActor = this->collider.base.at;
+        if (hitActor->id == ACTOR_WIND_ZONE) {
+            this->wz = hitActor;
+            this->inWindZone = true;
+        }
+        else {
+            this->wz = NULL;
+            this->inWindZone = false;
+        }
+    }
+    else {
+        this->wz = NULL;
+        this->inWindZone = false;
+    }
+    if (this->inWindZone) {
+        this->wzDistY = this->actor.world.pos.y - this->wz->actor.world.pos.y;
+    }
+
+
+
+    Collider_UpdateCylinder(&this->actor, &this->collider);
+    CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);
+    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);
+}
+
+
+
+void EnGlider_Draw(Actor* thisx, PlayState* play) {
+    Gfx_DrawDListOpa(play, gGliderDL);
+}
\ No newline at end of file
diff --git a/soh/src/overlays/actors/ovl_En_Glider/z_en_glider.h b/soh/src/overlays/actors/ovl_En_Glider/z_en_glider.h
new file mode 100644
index 00000000..d9c5b260
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_En_Glider/z_en_glider.h
@@ -0,0 +1,84 @@
+﻿#ifndef Z_EN_GLIDER_H
+#define Z_EN_GLIDER_H
+
+#include "overlays/actors/ovl_Wind_Zone/z_wind_zone.h"
+#include <libultraship/libultra.h>
+#include "global.h"
+
+struct EnGlider;
+
+typedef void (*EnGliderActionFunc)(struct EnGlider*, PlayState*);
+
+
+typedef struct EnGlider {
+    /* 0x0000 */ Actor actor;
+    /* 0x014C */ SkelAnime skelAnime;
+    /* 0x0190 */ Vec3s jointTable[16];
+    /* 0x01F0 */ Vec3s morphTable[16];
+    /* 0x0250 */ EnGliderActionFunc actionFunc;
+    /* 0x0254 */ s16 timer1;
+    /* 0x0256 */ s16 timer2;
+    /* 0x0258 */ s16 timer3;
+    /* 0x025A */ s16 timer4;
+    /* 0x025C */ s16 timer5;
+    /* 0x025E */ s16 timer6;
+    /* 0x0260 */ s16 sfxTimer1;
+    /* 0x0262 */ s16 sfxTimer2;
+    /* 0x0264 */ s16 sfxTimer3;
+    /* 0x0266 */ s16 timer7;
+    /* 0x0268 */ s16 timer8;
+    /* 0x026A */ s16 timer9;
+    /* 0x026C */ f32 unk_26C[10];
+    /* 0x0294 */ s16 unk_294;
+    /* 0x0296 */ s16 unk_296;
+    /* 0x0298 */ s16 unk_298;
+    /* 0x029A */ s16 unk_29A;
+    /* 0x029C */ s16 unk_29C;
+    /* 0x029E */ s16 unk_29E;
+    /* 0x02A0 */ s16 unk_2A0;
+    /* 0x02A2 */ s16 unk_2A2;
+    /* 0x02A4 */ s16 unk_2A4;
+    /* 0x02A6 */ s16 unk_2A6;
+    /* 0x02A8 */ s16 unk_2A8;
+    /* 0x02AA */ s16 unk_2AA;
+    /* 0x02AC */ Vec3f unk_2AC;
+    /* 0x02B8 */ Vec3f unk_2B8;
+    /* 0x02C4 */ f32 unk_2C4;
+    /* 0x02C8 */ f32 unk_2C8;
+    /* 0x02CC */ f32 unk_2CC;
+    /* 0x02D0 */ f32 unk_2D0;
+    /* 0x02D4 */ f32 unk_2D4;
+    /* 0x02D8 */ f32 unk_2D8;
+    /* 0x02DC */ f32 unk_2DC;
+    /* 0x02E0 */ f32 unk_2E0;
+    /* 0x02E4 */ s16 unk_2E4;
+    /* 0x02E6 */ s16 unk_2E6;
+    /* 0x02E8 */ s16 path;
+    /* 0x02EA */ s16 waypoint;
+    /* 0x02EC */ s16 unk_2EC;
+    /* 0x02EE */ s16 unk_2EE;
+    /* 0x02F0 */ Vec3f unk_2F0;
+    /* 0x02FC */ f32 unk_2FC;
+    /* 0x0300 */ f32 unk_300;
+    /* 0x0304 */ f32 unk_304;
+    /* 0x0308 */ u8 unk_308;
+    /* 0x030C */ ColliderCylinder collider;
+    WindZone* wz;
+    bool inWindZone;
+    float wzDistY;
+
+} EnGlider; // size = 0x07B8
+
+#ifdef __cplusplus
+#define this thisx
+extern "C"
+{
+#endif
+
+#ifdef __cplusplus
+#undef this
+};
+#undef this
+#endif
+
+#endif
diff --git a/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.c b/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.c
index 75e54c14..0573d326 100644
--- a/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.c
+++ b/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.c
@@ -9,6 +9,7 @@
 #include "objects/gameplay_keep/gameplay_keep.h"
 #include "objects/gameplay_field_keep/gameplay_field_keep.h"
 #include "objects/object_kusa/object_kusa.h"
+#include "overlays/actors/ovl_Lantern_Fire/z_lantern_fire.h"
 #include "vt.h"
 
 #define FLAGS (ACTOR_FLAG_UPDATE_WHILE_CULLED | ACTOR_FLAG_ALWAYS_THROWN)
@@ -35,11 +36,15 @@ void EnKusa_DoNothing(EnKusa* this, PlayState* play);
 void EnKusa_UprootedWaitRegrow(EnKusa* this, PlayState* play);
 void EnKusa_Regrow(EnKusa* this, PlayState* play);
 
+bool BurnOnLanternFire(EnKusa* this, ColliderCylinder cylinder, PlayState* play);
+
 static s16 rotSpeedXtarget = 0;
 static s16 rotSpeedX = 0;
 static s16 rotSpeedYtarget = 0;
 static s16 rotSpeedY = 0;
 
+int burnTime = 200;
+
 const ActorInit En_Kusa_InitVars = {
     ACTOR_EN_KUSA,
     ACTORCAT_PROP,
@@ -67,7 +72,7 @@ static ColliderCylinderInit sCylinderInit = {
     {
         ELEMTYPE_UNK0,
         { 0x00000000, 0x00, 0x00 },
-        { 0x4FC00758, 0x00, 0x00 },
+        { 0x4FC00778, 0x00, 0x00 }, //0x4FC00758 default plus 0x00000020 for arrow damage
         TOUCH_NONE,
         BUMP_ON,
         OCELEM_ON,
@@ -114,7 +119,8 @@ s32 EnKusa_SnapToFloor(EnKusa* this, PlayState* play, f32 yOffset) {
         this->actor.world.pos.y = floorY + yOffset;
         Math_Vec3f_Copy(&this->actor.home.pos, &this->actor.world.pos);
         return true;
-    } else {
+    }
+    else {
         osSyncPrintf(VT_COL(YELLOW, BLACK));
         // "Failure attaching to ground"
         osSyncPrintf("地面に付着失敗(%s %d)\n", __FILE__, __LINE__);
@@ -127,27 +133,28 @@ void EnKusa_DropCollectible(EnKusa* this, PlayState* play) {
     s16 dropParams;
 
     switch (this->actor.params & 3) {
-        case ENKUSA_TYPE_0:
-        case ENKUSA_TYPE_2:
-            dropParams = (this->actor.params >> 8) & 0xF;
+    case ENKUSA_TYPE_0:
+    case ENKUSA_TYPE_2:
+        dropParams = (this->actor.params >> 8) & 0xF;
 
-            if (dropParams >= 0xD) {
-                dropParams = 0;
-            }
-            Item_DropCollectibleRandom(play, NULL, &this->actor.world.pos, dropParams << 4);
-            break;
-        case ENKUSA_TYPE_1:
-            if (CVarGetInteger("gNoRandomDrops", 0)) {
-            }
-            else if (CVarGetInteger("gNoHeartDrops", 0)) {
-                Item_DropCollectible(play, &this->actor.world.pos, ITEM00_SEEDS);
-            }
-            else if (Rand_ZeroOne() < 0.5f) {
-                Item_DropCollectible(play, &this->actor.world.pos, ITEM00_SEEDS);
-            } else {
-                Item_DropCollectible(play, &this->actor.world.pos, ITEM00_HEART);
-            }
-            break;
+        if (dropParams >= 0xD) {
+            dropParams = 0;
+        }
+        Item_DropCollectibleRandom(play, NULL, &this->actor.world.pos, dropParams << 4);
+        break;
+    case ENKUSA_TYPE_1:
+        if (CVarGetInteger("gNoRandomDrops", 0)) {
+        }
+        else if (CVarGetInteger("gNoHeartDrops", 0)) {
+            Item_DropCollectible(play, &this->actor.world.pos, ITEM00_SEEDS);
+        }
+        else if (Rand_ZeroOne() < 0.5f) {
+            Item_DropCollectible(play, &this->actor.world.pos, ITEM00_SEEDS);
+        }
+        else {
+            Item_DropCollectible(play, &this->actor.world.pos, ITEM00_HEART);
+        }
+        break;
     }
 }
 
@@ -194,7 +201,7 @@ void EnKusa_SpawnFragments(EnKusa* this, PlayState* play) {
         scaleIndex = (s32)(Rand_ZeroOne() * 111.1f) & 7;
 
         EffectSsKakera_Spawn(play, &pos, &velocity, &pos, -100, 64, 40, 3, 0, sFragmentScales[scaleIndex], 0, 0,
-                             80, KAKERA_COLOR_NONE, OBJECT_GAMEPLAY_KEEP, gCuttableShrubStalkDL);
+            80, KAKERA_COLOR_NONE, OBJECT_GAMEPLAY_KEEP, gCuttableShrubStalkDL);
 
         pos.x = this->actor.world.pos.x + (dir->x * this->actor.scale.x * 40.0f);
         pos.y = this->actor.world.pos.y + (dir->y * this->actor.scale.y * 40.0f) + 10.0f;
@@ -207,7 +214,7 @@ void EnKusa_SpawnFragments(EnKusa* this, PlayState* play) {
         scaleIndex = (s32)(Rand_ZeroOne() * 111.1f) % 7;
 
         EffectSsKakera_Spawn(play, &pos, &velocity, &pos, -100, 64, 40, 3, 0, sFragmentScales[scaleIndex], 0, 0,
-                             80, KAKERA_COLOR_NONE, OBJECT_GAMEPLAY_KEEP, gCuttableShrubTipDL);
+            80, KAKERA_COLOR_NONE, OBJECT_GAMEPLAY_KEEP, gCuttableShrubTipDL);
     }
 }
 
@@ -216,7 +223,7 @@ void EnKusa_SpawnBugs(EnKusa* this, PlayState* play) {
 
     for (i = 0; i < 3; i++) {
         Actor* bug = Actor_Spawn(&play->actorCtx, play, ACTOR_EN_INSECT, this->actor.world.pos.x,
-                                 this->actor.world.pos.y, this->actor.world.pos.z, 0, Rand_ZeroOne() * 0xFFFF, 0, 1, true);
+            this->actor.world.pos.y, this->actor.world.pos.z, 0, Rand_ZeroOne() * 0xFFFF, 0, 1, true);
 
         if (bug == NULL) {
             break;
@@ -289,7 +296,8 @@ void EnKusa_WaitObject(EnKusa* this, PlayState* play) {
     if (Object_IsLoaded(&play->objectCtx, this->objBankIndex)) {
         if (this->actor.flags & ACTOR_FLAG_ENKUSA_CUT) {
             EnKusa_SetupCut(this);
-        } else {
+        }
+        else {
             EnKusa_SetupMain(this);
         }
 
@@ -310,7 +318,11 @@ void EnKusa_Main(EnKusa* this, PlayState* play) {
     if (Actor_HasParent(&this->actor, play)) {
         EnKusa_SetupLiftedUp(this);
         SoundSource_PlaySfxAtFixedWorldPos(play, &this->actor.world.pos, 20, NA_SE_PL_PULL_UP_PLANT);
-    } else if (this->collider.base.acFlags & AC_HIT && gPlayState->csCtx.state == 0) {
+    }
+    else if (BurnOnLanternFire(this, this->collider, play)) {
+
+    }
+    else if (this->collider.base.acFlags & AC_HIT && gPlayState->csCtx.state == 0) {
         this->collider.base.acFlags &= ~AC_HIT;
         EnKusa_SpawnFragments(this, play);
         EnKusa_DropCollectible(this, play);
@@ -328,7 +340,8 @@ void EnKusa_Main(EnKusa* this, PlayState* play) {
 
         EnKusa_SetupCut(this);
         this->actor.flags |= ACTOR_FLAG_ENKUSA_CUT;
-    } else {
+    }
+    else {
         if (!(this->collider.base.ocFlags1 & OC1_TYPE_PLAYER) && (this->actor.xzDistToPlayer > 12.0f)) {
             this->collider.base.ocFlags1 |= OC1_TYPE_PLAYER;
         }
@@ -389,14 +402,14 @@ void EnKusa_Fall(EnKusa* this, PlayState* play) {
         EnKusa_SpawnFragments(this, play);
         EnKusa_DropCollectible(this, play);
         switch (this->actor.params & 3) {
-            case ENKUSA_TYPE_0:
-            case ENKUSA_TYPE_2:
-                Actor_Kill(&this->actor);
-                break;
-
-            case ENKUSA_TYPE_1:
-                EnKusa_SetupUprootedWaitRegrow(this);
-                break;
+        case ENKUSA_TYPE_0:
+        case ENKUSA_TYPE_2:
+            Actor_Kill(&this->actor);
+            break;
+
+        case ENKUSA_TYPE_1:
+            EnKusa_SetupUprootedWaitRegrow(this);
+            break;
         }
         return;
     }
@@ -432,12 +445,12 @@ void EnKusa_Fall(EnKusa* this, PlayState* play) {
 
 void EnKusa_SetupCut(EnKusa* this) {
     switch (this->actor.params & 3) {
-        case ENKUSA_TYPE_2:
-            EnKusa_SetupAction(this, EnKusa_DoNothing);
-            break;
-        case ENKUSA_TYPE_1:
-            EnKusa_SetupAction(this, EnKusa_CutWaitRegrow);
-            break;
+    case ENKUSA_TYPE_2:
+        EnKusa_SetupAction(this, EnKusa_DoNothing);
+        break;
+    case ENKUSA_TYPE_1:
+        EnKusa_SetupAction(this, EnKusa_CutWaitRegrow);
+        break;
     }
 }
 
@@ -499,7 +512,8 @@ void EnKusa_Update(Actor* thisx, PlayState* play) {
 
     if (this->actor.flags & ACTOR_FLAG_ENKUSA_CUT) {
         this->actor.shape.yOffset = -6.25f;
-    } else {
+    }
+    else {
         this->actor.shape.yOffset = 0.0f;
     }
 }
@@ -510,7 +524,36 @@ void EnKusa_Draw(Actor* thisx, PlayState* play) {
 
     if (this->actor.flags & ACTOR_FLAG_ENKUSA_CUT) {
         Gfx_DrawDListOpa(play, object_kusa_DL_0002E0);
-    } else {
+    }
+    else {
         Gfx_DrawDListOpa(play, dLists[thisx->params & 3]);
     }
 }
+
+bool BurnOnLanternFire(EnKusa* this, ColliderCylinder cylinder, PlayState* play) {
+    if (cylinder.base.acFlags & AC_HIT) {
+        cylinder.base.acFlags &= ~AC_HIT;
+        if ((cylinder.base.ac != NULL) && (cylinder.base.ac->id == ACTOR_LANTERN_FIRE)) {
+            if (cylinder.base.ac->params >= 1) { // is Blue Fire
+                if (this->isBurning == false) {
+                    this->isBurning = true;
+                    this->fire = (LanternFire*)cylinder.base.ac;
+                    this->fire->deathTimer = burnTime;
+                    Audio_PlayActorSound2(&this->actor, NA_SE_EV_FLAME_IGNITION);
+                }
+                else {
+                    if (this->fire->deathTimer == 0) {
+                        return 0;
+                    }
+                    else {
+                        float scale = 0.1f + 0.3f * ((float)this->fire->deathTimer / (float)burnTime);
+                        Actor_SetScale(&this->actor, scale);
+                    }
+                }
+                return 1; //is hit by Blue Fire
+            }
+        }
+        return 0;
+    }
+    return 0;
+}
diff --git a/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.h b/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.h
index f1e9f24d..b4a80676 100644
--- a/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.h
+++ b/soh/src/overlays/actors/ovl_En_Kusa/z_en_kusa.h
@@ -1,6 +1,7 @@
 #ifndef Z_EN_KUSA_H
 #define Z_EN_KUSA_H
 
+#include "overlays/actors/ovl_Lantern_Fire/z_lantern_fire.h"
 #include <libultraship/libultra.h>
 #include "global.h"
 
@@ -20,6 +21,8 @@ typedef struct EnKusa {
     /* 0x0150 */ ColliderCylinder collider;
     /* 0x019C */ s16 timer;
     /* 0x019E */ s8 objBankIndex;
+    bool isBurning;
+    LanternFire* fire;
 } EnKusa; // size = 0x01A0
 
 #endif
diff --git a/soh/src/overlays/actors/ovl_En_Zf/z_en_zf.c b/soh/src/overlays/actors/ovl_En_Zf/z_en_zf.c
index 9aa8204d..74a3c32c 100644
--- a/soh/src/overlays/actors/ovl_En_Zf/z_en_zf.c
+++ b/soh/src/overlays/actors/ovl_En_Zf/z_en_zf.c
@@ -542,7 +542,7 @@ s32 EnZf_CanAttack(PlayState* play, EnZf* this) {
             return true;
         }
         if (this->actor.params == ENZF_TYPE_DINOLFOS) {
-            targetedActor = player->unk_664;
+            targetedActor = player->targetActorMaybe;
             if (targetedActor == NULL) {
                 return false;
             } else {
diff --git a/soh/src/overlays/actors/ovl_Lantern_Fire/z_lantern_fire.c b/soh/src/overlays/actors/ovl_Lantern_Fire/z_lantern_fire.c
new file mode 100644
index 00000000..0b83301e
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_Lantern_Fire/z_lantern_fire.c
@@ -0,0 +1,336 @@
+#include "z_lantern_fire.h"
+#include "objects/gameplay_keep/gameplay_keep.h"
+#include "overlays/actors/ovl_Wind_Zone/z_wind_zone.h"
+
+#define FLAGS ( ACTOR_FLAG_FRIENDLY | ACTOR_FLAG_UPDATE_WHILE_CULLED)
+
+void LanternFire_Init(Actor* thisx, PlayState* play);
+void LanternFire_Destroy(Actor* thisx, PlayState* play);
+void LanternFire_Update(Actor* thisx, PlayState* play);
+void LanternFire_Draw(Actor* thisx, PlayState* play);
+void LanternFire_Disappear(LanternFire* this, PlayState* play);
+void LanternFire_WaitToDie(LanternFire* this, PlayState* play);
+
+const ActorInit Lantern_Fire_InitVars = {
+    ACTOR_LANTERN_FIRE,
+    ACTORCAT_ITEMACTION,
+    FLAGS,
+    OBJECT_GAMEPLAY_KEEP,
+    sizeof(LanternFire),
+    (ActorFunc)LanternFire_Init,
+    (ActorFunc)LanternFire_Destroy,
+    (ActorFunc)LanternFire_Update,
+    (ActorFunc)LanternFire_Draw,
+    NULL,
+};
+
+
+static ColliderCylinderInit sCylinderInitRedFire = { //damages enemies
+    {
+        COLTYPE_NONE,
+        AT_ON | AT_TYPE_PLAYER,
+        AC_NONE,
+        OC1_NONE,
+        OC2_TYPE_PLAYER,
+        COLSHAPE_CYLINDER,
+    },
+    {
+        ELEMTYPE_UNK2,
+        { 0x00000020, 0x00, 0x00 }, // normal arrow damage type 
+        { 0xFFCFFFFF, 0x00, 0x00 },
+        TOUCH_ON | TOUCH_NEAREST | TOUCH_SFX_NONE,
+        BUMP_NONE,
+        OCELEM_NONE,
+    },
+    { 23, 46, 0, { 0, 0, 0 } },
+};
+
+static ColliderCylinderInit sCylinderInitBlueFire = { //damages enemies
+    {
+        COLTYPE_NONE,
+        AT_ON | AT_TYPE_OTHER,
+        AC_NONE,
+        OC1_ON | OC1_TYPE_2,
+        OC2_TYPE_2,
+        COLSHAPE_CYLINDER,
+    },
+    {
+        ELEMTYPE_UNK0,
+        { 0x00000020, 0x00, 0x00 }, // normal arrow damage type 
+        { 0xFFCFFFFF, 0x00, 0x00 },
+        TOUCH_ON | TOUCH_SFX_NORMAL,
+        BUMP_NONE,
+        OCELEM_ON,
+    },
+    { 23, 46, 0, { 0, 0, 0 } },
+};
+
+static CollisionCheckInfoInit2 sColChkInit = { 1, 0, 0, 0, MASS_IMMOVABLE };
+
+
+void LanternFire_UpdatePos(LanternFire* this, Vec3f* targetPos) {
+    f32 dist;
+    f32 xDiff = targetPos->x - this->actor.world.pos.x;
+    f32 yDiff = targetPos->y - this->actor.world.pos.y;
+    f32 zDiff = targetPos->z - this->actor.world.pos.z;
+
+    dist = sqrtf(SQ(xDiff) + SQ(yDiff) + SQ(zDiff));
+    if (fabsf(dist) > fabsf(this->actor.speedXZ)) {
+        this->actor.velocity.x = (xDiff / dist) * this->actor.speedXZ;
+        this->actor.velocity.z = (zDiff / dist) * this->actor.speedXZ;
+    } else {
+        this->actor.velocity.x = 0.0f;
+        this->actor.velocity.z = 0.0f;
+    }
+
+    this->actor.velocity.y += this->actor.gravity;
+    if (!(this->actor.minVelocityY <= this->actor.velocity.y)) {
+        this->actor.velocity.y = this->actor.minVelocityY;
+    }
+}
+
+s32 LanternFire_CheckCollider(LanternFire* this, PlayState* play) {
+    if (this->actionFunc == LanternFire_Disappear) {
+        return false;
+    }
+
+    if (this->collider.base.acFlags & AC_HIT) {
+        this->collider.base.acFlags &= ~AC_HIT;
+        return true;
+    }
+
+    if (this->collider.base.ocFlags2 & OC2_HIT_PLAYER) {
+        this->collider.base.ocFlags2 &= ~OC2_HIT_PLAYER;
+        return true;
+    }
+    return false;
+}
+
+void LanternFire_Init(Actor* thisx, PlayState* play) {
+    LanternFire* this = (LanternFire*)thisx;
+    s32 pad;
+    Player* player = GET_PLAYER(play);
+    thisx->room = -1;
+
+    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);
+
+    Collider_InitCylinder(play, &this->collider);
+
+    if (this->actor.params == 0) { // regular fire
+        Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInitRedFire);
+        this->collider.info.toucherFlags &= ~0x18;
+        this->collider.info.toucherFlags |= 0;
+        this->collider.info.toucher.dmgFlags = 0x00000800;
+    }
+    else if (this->actor.params == 1) //Blue Fire
+    {
+        Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInitBlueFire);
+    }
+    else { //Green or Purple 
+        Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInitRedFire);
+    }
+    // params == 1 Blue Fire
+    //Taken care of in "z_bg_ice_shelter.c"  Red Ice
+    //Taken care of in "z_en_kusa.c"  Bushes
+    this->actor.gravity = -0.6f;
+    this->actor.speedXZ = 5.0f;
+    this->actor.velocity.y = 2.0f;
+    this->deathTimer = 100;
+    this->actor.parent = NULL;
+    this->actor.flags &= ~ACTOR_FLAG_TARGETABLE;
+    this->scale = 3.0f;
+    this->tile2Y = (s16)Rand_ZeroFloat(5.0f) - 25;
+}
+
+void LanternFire_Destroy(Actor* thisx, PlayState* play) {
+    LanternFire* this = (LanternFire*)thisx;
+    if (this->wz != NULL) this->wz->deathTimer = 0;
+    Collider_DestroyCylinder(play, &this->collider);
+}
+
+
+void LanternFire_WaitToDie(LanternFire* this, PlayState* play) {
+    if (DECR(this->deathTimer) == 0) {
+        this->actionFunc = LanternFire_Disappear;
+    }
+}
+
+
+void LanternFire_Disappear(LanternFire* this, PlayState* play) {
+    Math_SmoothStepToF(&this->scale, 0.0f, 0.3f, 0.2f, 0.0f);
+    this->actor.shape.shadowScale = 20.0f;
+    this->actor.shape.shadowScale *= (this->scale / 3.0f);
+    if (!(this->scale > 0.02f)) {
+        if (this->wz != NULL) this->wz->deathTimer = 0;
+        Actor_Kill(&this->actor);
+    }
+}
+
+void LanternFire_Update(Actor* thisx, PlayState* play) {
+    LanternFire* this = (LanternFire*)thisx;
+    s32 pad;
+    s32 atTouched;
+    Actor* hitActor;
+
+    if (this->actionFunc != LanternFire_Disappear) {
+        if (LanternFire_CheckCollider(this, play)) {
+            this->actionFunc = LanternFire_Disappear;
+        }
+        else {
+            this->actionFunc = LanternFire_WaitToDie;
+        }
+    }
+    if (this->actor.world.pos.y - this->actor.floorHeight > 0.2f) {
+        this->actor.speedXZ = 5.0f;
+        Actor_MoveForward(&this->actor);
+    }
+    else {
+        this->actor.speedXZ = 0.0f;
+        Actor_MoveForward(&this->actor);
+    }
+    if (this->actor.parent == NULL) {
+        atTouched = (this->collider.base.atFlags & AT_HIT);
+        if (atTouched && (this->collider.info.atHitInfo->elemType != ELEMTYPE_UNK4)) {
+            hitActor = this->collider.base.at;
+            this->hitFlags |= 1;
+            this->hitFlags |= 2;
+
+            if (this->collider.info.atHitInfo->bumperFlags & 2) {
+                this->actor.world.pos.x = this->collider.info.atHitInfo->bumper.hitPos.x;
+                this->actor.world.pos.y = this->collider.info.atHitInfo->bumper.hitPos.y;
+                this->actor.world.pos.z = this->collider.info.atHitInfo->bumper.hitPos.z;
+                if (hitActor->id == ACTOR_EN_KUSA) {
+                    if (hitActor->child == NULL) {
+                        this->actor.parent = hitActor;
+                        this->scale = 5.0f;
+                        this->actor.world.pos = this->actor.parent->world.pos;
+                        this->wz = Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_WIND_ZONE,
+                            this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, 0,
+                            this->actor.shape.rot.y, 1, 0);
+                    }
+                }
+                else {
+                    this->actionFunc = LanternFire_Disappear;
+                }
+            }
+        }
+        else {
+            //if (this->actor.bgCheckFlags & 0x1) this->collider.dim.radius *= 1.05f; //grow slightly if touching the ground
+        }
+    }
+    else {
+        this->actor.world.pos = this->actor.parent->world.pos;
+    }
+
+    this->actionFunc(this, play);
+    Actor_UpdateBgCheckInfo(play, &this->actor, 12.0f, 10.0f, 0.0f, 5);
+
+    if (this->actionFunc != LanternFire_Disappear) {
+        Collider_UpdateCylinder(&this->actor, &this->collider);
+        CollisionCheck_SetAT(play, &play->colChkCtx, &this->collider.base);
+        CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);
+    }
+}
+
+void LanternFire_Draw(Actor* thisx, PlayState* play) {
+    int r1 = 0, r2 = 0, g1 = 0, g2 = 0, b1 = 0, b2 = 0, a1 = 0;
+    if (thisx->params == 0) { //Red
+        r1 = 255;
+        g1 = 200;
+        b1 = 0;
+        a1 = 255;
+        r2 = 255;
+        g2 = 0;
+        b2 = 0;
+    }
+    if (thisx->params == 1) { //Blue
+        r1 = 0;
+        g1 = 170;
+        b1 = 255;
+        a1 = 255;
+        r2 = 0;
+        g2 = 0;
+        b2 = 255;
+    }
+    if (thisx->params == 2) { //Green
+        r1 = 170;
+        g1 = 255;
+        b1 = 0;
+        a1 = 255;
+        r2 = 0;
+        g2 = 150;
+        b2 = 0;
+    }
+    if (thisx->params == 3) { //Purple
+        r1 = 255;
+        g1 = 170;
+        b1 = 255;
+        a1 = 255;
+        r2 = 100;
+        g2 = 0;
+        b2 = 255;
+    }
+    if (thisx->params == 4) { //White / Updraft
+        r1 = 170;
+        g1 = 170;
+        b1 = 170;
+        a1 = 96;
+        r2 = 255;
+        g2 = 255;
+        b2 = 255;
+    }
+
+    Color_RGBA8 primColors[] = { //yellow inside
+        { r1, g1, b1, 128 },
+        { 0, 0, 0, 255 }, //nothing
+    };
+    Color_RGBA8 envColors[] = { //red outside
+        { r2, g2, b2, 255 }, //Alpha Does Nothing
+        { 0, 0, 0, 255 }, //nothing
+    };
+    s32 pad;
+    LanternFire* this = (LanternFire*)thisx;
+    Vec3f scale = { 0.0f, 0.0f, 0.0f };
+    Vec3f sp90 = { 0.0f, 0.0f, 0.0f };
+    s16 sp8E;
+    f32 sp88;
+    f32 sp84;
+    f32 sp80;
+
+    OPEN_DISPS(play->state.gfxCtx);
+
+    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);
+    sp8E = Math_Vec3f_Yaw(&scale, &this->actor.velocity) - Camera_GetCamDirYaw(GET_ACTIVE_CAM(play));
+    sp84 = fabsf(Math_CosS(sp8E));
+    sp88 = Math_SinS(sp8E);
+    sp80 = Math_Vec3f_DistXZ(&scale, &this->actor.velocity) / 1.5f;
+    Matrix_RotateY((s16)(Camera_GetCamDirYaw(GET_ACTIVE_CAM(play)) + 0x8000) * (M_PI / 0x8000), MTXMODE_APPLY);
+    Matrix_RotateZ(((sp88 * -10.0f) * sp80) * (M_PI / 180.0f), MTXMODE_APPLY);
+    scale.x = scale.y = scale.z = this->scale * 0.001f;
+    Matrix_Scale(scale.x, scale.y, scale.z, MTXMODE_APPLY);
+    sp84 = sp80 * ((0.01f * -15.0f) * sp84) + 1.0f;
+    if (sp84 < 0.1f) {
+        sp84 = 0.1f;
+    }
+    Matrix_Scale(1.0f, sp84, 1.0f / sp84, MTXMODE_APPLY);
+    gSPMatrix(POLY_XLU_DISP++, MATRIX_NEWMTX(play->state.gfxCtx),
+              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
+    Gfx_SetupDL_25Xlu(play->state.gfxCtx);
+    gSPSegment(POLY_XLU_DISP++, 0x8,
+               Gfx_TwoTexScroll(play->state.gfxCtx, 0, 0, 0, 0x20, 0x40, 1, 0,
+                                play->state.frames * this->tile2Y, 0x20, 0x80));
+    gDPSetPrimColor(POLY_XLU_DISP++, 128, 128, primColors[((this->actor.params & 0x8000) >> 0xF)].r,
+        primColors[((this->actor.params & 0x8000) >> 0xF)].g,
+        primColors[((this->actor.params & 0x8000) >> 0xF)].b,
+        primColors[((this->actor.params & 0x8000) >> 0xF)].a);
+    gDPSetEnvColor(POLY_XLU_DISP++, envColors[((this->actor.params & 0x8000) >> 0xF)].r,
+        envColors[((this->actor.params & 0x8000) >> 0xF)].g,
+        envColors[((this->actor.params & 0x8000) >> 0xF)].b,
+        envColors[((this->actor.params & 0x8000) >> 0xF)].a);
+    gDPPipeSync(POLY_XLU_DISP++);
+    
+    if(thisx->params == 4) gSPDisplayList(POLY_XLU_DISP++, gEffFire2DL);
+    else gSPDisplayList(POLY_XLU_DISP++, gEffFire1DL);
+
+    CLOSE_DISPS(play->state.gfxCtx);
+}
diff --git a/soh/src/overlays/actors/ovl_Lantern_Fire/z_lantern_fire.h b/soh/src/overlays/actors/ovl_Lantern_Fire/z_lantern_fire.h
new file mode 100644
index 00000000..b8963e0a
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_Lantern_Fire/z_lantern_fire.h
@@ -0,0 +1,29 @@
+#ifndef Z_LANTERN_FIRE_H
+#define Z_LANTERN_FIRE_H
+
+#include "overlays/actors/ovl_Wind_Zone/z_wind_zone.h"
+#include <libultraship/libultra.h>
+#include "global.h"
+
+struct LanternFire;
+
+typedef void (*LanternFireActionFunc)(struct LanternFire* this, PlayState* play);
+
+typedef struct LanternFire {
+    /* 0x0000 */ Actor actor;
+    /* 0x014C */ LanternFireActionFunc actionFunc;
+    /* 0x0150 */ ColliderCylinder collider;
+    /* 0x019C */ f32 spawnRadius;
+    /* 0x01A0 */ f32 scale;
+    /* 0x01A4 */ char unk_1A4[0x2];
+    /* 0x01A6 */ s16 deathTimer;
+    /* 0x01A8 */ s16 tile2Y;
+    /* 0x022C */ WeaponInfo weaponInfo;
+    /* 0x0248 */ u8 timer; // used for dissapearing when flying or hitting a wall
+    /* 0x0249 */ u8 hitFlags;
+    /* 0x024A */ u8 touchedPoly;
+    /* 0x024C */ Actor* hitActor;
+    WindZone* wz;
+} LanternFire; // size = 0x01AC
+
+#endif
diff --git a/soh/src/overlays/actors/ovl_Obj_Bombiwa/z_obj_bombiwa.c b/soh/src/overlays/actors/ovl_Obj_Bombiwa/z_obj_bombiwa.c
index b300b685..a6098982 100644
--- a/soh/src/overlays/actors/ovl_Obj_Bombiwa/z_obj_bombiwa.c
+++ b/soh/src/overlays/actors/ovl_Obj_Bombiwa/z_obj_bombiwa.c
@@ -124,7 +124,6 @@ void ObjBombiwa_Break(ObjBombiwa* this, PlayState* play) {
 void ObjBombiwa_Update(Actor* thisx, PlayState* play) {
     ObjBombiwa* this = (ObjBombiwa*)thisx;
     s32 pad;
-
     if ((func_80033684(play, &this->actor) != NULL) ||
         ((this->collider.base.acFlags & AC_HIT) && (this->collider.info.acHitInfo->toucher.dmgFlags & 0x40000040))) {
         ObjBombiwa_Break(this, play);
@@ -141,6 +140,7 @@ void ObjBombiwa_Update(Actor* thisx, PlayState* play) {
             CollisionCheck_SetOC(play, &play->colChkCtx, &this->collider.base);
         }
     }
+    Collider_UpdateCylinder(&this->actor, &this->collider); //ADDED THIS TO MAKE COLLIDER MOVE WITH WORLD POSITION
 }
 
 void ObjBombiwa_Draw(Actor* thisx, PlayState* play) {
diff --git a/soh/src/overlays/actors/ovl_Wind_Zone/z_wind_zone.c b/soh/src/overlays/actors/ovl_Wind_Zone/z_wind_zone.c
new file mode 100644
index 00000000..d37fd1fd
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_Wind_Zone/z_wind_zone.c
@@ -0,0 +1,228 @@
+#include "z_wind_zone.h"
+#include "objects/gameplay_keep/gameplay_keep.h"
+#include "overlays/actors/ovl_En_Glider/z_en_glider.h"
+
+#define FLAGS (ACTOR_FLAG_UPDATE_WHILE_CULLED | ACTOR_FLAG_ALWAYS_THROWN)
+
+void WindZone_Init(Actor* thisx, PlayState* play);
+void WindZone_Destroy(Actor* thisx, PlayState* play);
+void WindZone_Update(Actor* thisx, PlayState* play);
+void WindZone_Draw(Actor* thisx, PlayState* play);
+void WindZone_Disappear(WindZone* this, PlayState* play);
+bool GliderIsInZone(WindZone* this, ColliderCylinder cylinder, PlayState* play);
+
+const ActorInit Wind_Zone_InitVars = {
+    ACTOR_WIND_ZONE,
+    ACTORCAT_ITEMACTION,
+    FLAGS,
+    OBJECT_GAMEPLAY_KEEP,
+    sizeof(WindZone),
+    (ActorFunc)WindZone_Init,
+    (ActorFunc)WindZone_Destroy,
+    (ActorFunc)WindZone_Update,
+    (ActorFunc)WindZone_Draw,
+    NULL,
+};
+
+
+static ColliderCylinderInit sCylinderInit = {
+    {
+        COLTYPE_HARD,
+        AT_NONE,
+        AC_ON | AC_TYPE_PLAYER,
+        OC1_NONE,
+        OC2_TYPE_2,
+        COLSHAPE_CYLINDER,
+    },
+    {
+        ELEMTYPE_UNK0,
+        { 0x00000000, 0x00, 0x00 },
+        { 0x00100000, 0x00, 0x00 }, //only collides with gliders damage type 0x00100000
+        TOUCH_NONE,
+        BUMP_ON,
+        OCELEM_NONE,
+    },
+    { 50, 200, 0, { 0, 0, 0 } }, //Radius, Height
+};
+
+static CollisionCheckInfoInit sColChkInfoInit = { 0, 12, 30, MASS_IMMOVABLE };
+
+
+void WindZone_UpdatePos(WindZone* this, Vec3f* targetPos) {
+    f32 dist;
+    f32 xDiff = targetPos->x - this->actor.world.pos.x;
+    f32 yDiff = targetPos->y - this->actor.world.pos.y;
+    f32 zDiff = targetPos->z - this->actor.world.pos.z;
+
+    dist = sqrtf(SQ(xDiff) + SQ(yDiff) + SQ(zDiff));
+    if (fabsf(dist) > fabsf(this->actor.speedXZ)) {
+        this->actor.velocity.x = (xDiff / dist) * this->actor.speedXZ;
+        this->actor.velocity.z = (zDiff / dist) * this->actor.speedXZ;
+    } else {
+        this->actor.velocity.x = 0.0f;
+        this->actor.velocity.z = 0.0f;
+    }
+
+    this->actor.velocity.y += this->actor.gravity;
+    if (!(this->actor.minVelocityY <= this->actor.velocity.y)) {
+        this->actor.velocity.y = this->actor.minVelocityY;
+    }
+}
+
+s32 WindZone_CheckCollider(WindZone* this, PlayState* play) {
+    if (this->actionFunc == WindZone_Disappear) {
+        return false;
+    }
+    else if (this->collider.base.acFlags & AC_HIT && gPlayState->csCtx.state == 0) {
+        this->collider.base.acFlags &= ~AC_HIT;
+        return true;
+    }
+    else if (!(this->collider.base.ocFlags1 & OC1_TYPE_PLAYER) && (this->actor.xzDistToPlayer > 12.0f)) {
+        this->collider.base.ocFlags1 |= OC1_TYPE_PLAYER;
+        return true;
+    }
+    return false;
+}
+
+void WindZone_InitCollider(Actor* thisx, PlayState* play) {
+    WindZone* this = (WindZone*)thisx;
+
+    Collider_InitCylinder(play, &this->collider);
+    Collider_SetCylinder(play, &this->collider, &this->actor, &sCylinderInit);
+    Collider_UpdateCylinder(&this->actor, &this->collider);
+}
+
+void WindZone_Init(Actor* thisx, PlayState* play) {
+    WindZone* this = (WindZone*)thisx;
+    s32 pad;
+    Player* player = GET_PLAYER(play);
+    ActorShape_Init(&this->actor.shape, 0.0f, ActorShadow_DrawCircle, 20.0f);
+    WindZone_InitCollider(thisx, play);
+    CollisionCheck_SetInfo(&this->actor.colChkInfo, NULL, &sColChkInfoInit);
+
+    this->actor.flags &= ~ACTOR_FLAG_TARGETABLE;
+    this->scale = 3.0f;
+    this->tile2Y = (s16)Rand_ZeroFloat(5.0f) - 25;
+    this->deathTimer = 1000;
+    if (this->actor.params == 1) this->deathTimer = 120; //if Rivali's Gale then last 6 seconds
+}
+
+void WindZone_Destroy(Actor* thisx, PlayState* play) {
+    WindZone* this = (WindZone*)thisx;
+    Collider_DestroyCylinder(play, &this->collider);
+}
+
+
+
+void WindZone_Disappear(WindZone* this, PlayState* play) {
+    this->scale -= 0.6f;
+    this->actor.shape.shadowScale = 20.0f;
+    this->actor.shape.shadowScale *= (this->scale / 3.0f);
+    if (!(this->scale > 0.01f)) {
+        Actor_Kill(&this->actor);
+    }
+}
+
+void WindZone_Update(Actor* thisx, PlayState* play) {
+    WindZone* this = (WindZone*)thisx;
+    s32 pad;
+    s32 atTouched;
+    Actor* hitActor;
+    float targetScale = 20.0f;
+   
+    this->deathTimer--;
+    if (this->deathTimer <= 0) WindZone_Disappear(this, play);
+    else {
+        //if (GliderIsInZone(this, this->collider, play)) {
+
+        //}
+        //else {
+            WindZone_CheckCollider(this, play);
+            if (this->scale <= targetScale) this->scale += 0.3f;
+      //  }
+    }
+    Collider_UpdateCylinder(&this->actor, &this->collider);
+    CollisionCheck_SetAC(play, &play->colChkCtx, &this->collider.base);
+}
+
+
+
+void WindZone_Draw(Actor* thisx, PlayState* play) {
+    int r1 = 0, r2 = 0, g1 = 0, g2 = 0, b1 = 0, b2 = 0, a1 = 0;
+    if (thisx->params >= 0) { //White / Updraft
+        r1 = 170;
+        g1 = 170;
+        b1 = 170;
+        a1 = 96;
+        r2 = 255;
+        g2 = 255;
+        b2 = 255;
+    }
+
+    Color_RGBA8 primColors[] = { //yellow inside
+        { r1, g1, b1, 128 },
+        { 0, 0, 0, 255 }, //nothing
+    };
+    Color_RGBA8 envColors[] = { //red outside
+        { r2, g2, b2, 255 }, //Alpha Does Nothing
+        { 0, 0, 0, 255 }, //nothing
+    };
+    s32 pad;
+    WindZone* this = (WindZone*)thisx;
+    Vec3f scale = { 0.0f, 0.0f, 0.0f };
+    Vec3f sp90 = { 0.0f, 0.0f, 0.0f };
+    s16 sp8E;
+    f32 sp88;
+    f32 sp84;
+    f32 sp80;
+
+    OPEN_DISPS(play->state.gfxCtx);
+
+    Matrix_Translate(this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, MTXMODE_NEW);
+    sp8E = Math_Vec3f_Yaw(&scale, &this->actor.velocity) - Camera_GetCamDirYaw(GET_ACTIVE_CAM(play));
+    sp84 = fabsf(Math_CosS(sp8E));
+    sp88 = Math_SinS(sp8E);
+    sp80 = Math_Vec3f_DistXZ(&scale, &this->actor.velocity) / 1.5f;
+    Matrix_RotateY((s16)(Camera_GetCamDirYaw(GET_ACTIVE_CAM(play)) + 0x8000) * (M_PI / 0x8000), MTXMODE_APPLY);
+    Matrix_RotateZ(((sp88 * -10.0f) * sp80) * (M_PI / 180.0f), MTXMODE_APPLY);
+    scale.x = scale.y = scale.z = this->scale * 0.001f;
+    Matrix_Scale(scale.x, scale.y, scale.z, MTXMODE_APPLY);
+    sp84 = sp80 * ((0.01f * -15.0f) * sp84) + 1.0f;
+    if (sp84 < 0.1f) {
+        sp84 = 0.1f;
+    }
+    Matrix_Scale(1.0f, sp84, 1.0f / sp84, MTXMODE_APPLY);
+    gSPMatrix(POLY_XLU_DISP++, MATRIX_NEWMTX(play->state.gfxCtx),
+              G_MTX_NOPUSH | G_MTX_LOAD | G_MTX_MODELVIEW);
+    Gfx_SetupDL_25Xlu(play->state.gfxCtx);
+    gSPSegment(POLY_XLU_DISP++, 0x8,
+               Gfx_TwoTexScroll(play->state.gfxCtx, 0, 0, 0, 0x20, 0x40, 1, 0,
+                                play->state.frames * this->tile2Y, 0x20, 0x80));
+    gDPSetPrimColor(POLY_XLU_DISP++, 128, 128, primColors[((this->actor.params & 0x8000) >> 0xF)].r,
+        primColors[((this->actor.params & 0x8000) >> 0xF)].g,
+        primColors[((this->actor.params & 0x8000) >> 0xF)].b,
+        primColors[((this->actor.params & 0x8000) >> 0xF)].a);
+    gDPSetEnvColor(POLY_XLU_DISP++, envColors[((this->actor.params & 0x8000) >> 0xF)].r,
+        envColors[((this->actor.params & 0x8000) >> 0xF)].g,
+        envColors[((this->actor.params & 0x8000) >> 0xF)].b,
+        envColors[((this->actor.params & 0x8000) >> 0xF)].a);
+    gDPPipeSync(POLY_XLU_DISP++);
+    
+    if(thisx->params >= 0) gSPDisplayList(POLY_XLU_DISP++, gEffFire2DL);
+    else gSPDisplayList(POLY_XLU_DISP++, gEffFire1DL);
+
+    CLOSE_DISPS(play->state.gfxCtx);
+}
+
+bool GliderIsInZone(WindZone* this, ColliderCylinder cylinder, PlayState* play) {
+    if (cylinder.base.acFlags & AC_HIT) {
+        cylinder.base.acFlags &= ~AC_HIT;
+        if ((cylinder.base.ac != NULL) && (cylinder.base.ac->id == ACTOR_EN_GLIDER)) {
+            EnGlider* glider = (EnGlider*)cylinder.base.ac;
+            glider->inWindZone = true;
+            
+            return true;
+        }
+    }
+    return false;
+}
diff --git a/soh/src/overlays/actors/ovl_Wind_Zone/z_wind_zone.h b/soh/src/overlays/actors/ovl_Wind_Zone/z_wind_zone.h
new file mode 100644
index 00000000..1bc0c172
--- /dev/null
+++ b/soh/src/overlays/actors/ovl_Wind_Zone/z_wind_zone.h
@@ -0,0 +1,27 @@
+#ifndef Z_WIND_ZONE_H
+#define Z_WIND_ZONE_H
+
+#include <libultraship/libultra.h>
+#include "global.h"
+
+struct WindZone;
+
+typedef void (*WindZoneActionFunc)(struct WindZone* this, PlayState* play);
+
+typedef struct WindZone {
+    /* 0x0000 */ Actor actor;
+    /* 0x014C */ WindZoneActionFunc actionFunc;
+    /* 0x0150 */ ColliderCylinder collider;
+    /* 0x019C */ f32 spawnRadius;
+    /* 0x01A0 */ f32 scale;
+    /* 0x01A4 */ char unk_1A4[0x2];
+    /* 0x01A6 */ s16 deathTimer;
+    /* 0x01A8 */ s16 tile2Y;
+    /* 0x022C */ WeaponInfo weaponInfo;
+    /* 0x0248 */ u8 timer; // used for dissapearing when flying or hitting a wall
+    /* 0x0249 */ u8 hitFlags;
+    /* 0x024A */ u8 touchedPoly;
+    /* 0x024C */ Actor* hitActor;
+} WindZone; // size = 0x01AC
+
+#endif
diff --git a/soh/src/overlays/actors/ovl_player_actor/z_player.c b/soh/src/overlays/actors/ovl_player_actor/z_player.c
index 52dc2a3e..7e8ead85 100644
--- a/soh/src/overlays/actors/ovl_player_actor/z_player.c
+++ b/soh/src/overlays/actors/ovl_player_actor/z_player.c
@@ -31,6 +31,9 @@
 #include "soh/Enhancements/randomizer/randomizer_grotto.h"
 #include "soh/frame_interpolation.h"
 
+#include "overlays/actors/ovl_En_Glider/z_en_glider.h"
+#include "overlays/actors/ovl_Custom_Projectile/z_custom_projectile.h"
+
 #include <string.h>
 #include <stdlib.h>
 #include <assert.h>
@@ -124,13 +127,13 @@ typedef struct {
     /* 0x08 */ s16 unk_08;
 } struct_80858AC8; // size = 0x0A
 
-void func_80833770(PlayState* play, Player* this);
-void func_80833790(PlayState* play, Player* this);
-void func_8083379C(PlayState* play, Player* this);
+void ItemDoNothing(PlayState* play, Player* this);
+void ItemDoNothing2(PlayState* play, Player* this);
+void ItemSlingshotOrAnyBow(PlayState* play, Player* this);
 void func_8083377C(PlayState* play, Player* this);
-void func_808337D4(PlayState* play, Player* this);
-void func_80833910(PlayState* play, Player* this);
-void func_80833984(PlayState* play, Player* this);
+void ItemSpawnBomb(PlayState* play, Player* this);
+void ItemSpawnHookshot(PlayState* play, Player* this);
+void ItemBoomerangInHand(PlayState* play, Player* this);
 void func_8083399C(PlayState* play, Player* this, s8 actionParam);
 s32 func_8083485C(Player* this, PlayState* play);
 s32 func_808349DC(Player* this, PlayState* play);
@@ -353,6 +356,13 @@ s32 Player_InflictDamage(PlayState* play, s32 damage);
 s32 Player_InflictDamageModified(PlayState* play, s32 damage, u8 modified);
 void func_80853148(PlayState* play, Actor* actor);
 
+s32 SSBJump(PlayState* play, Player* this);
+s32 Glide(PlayState* play, Player* this);
+void ContinueItemAction(PlayState* play, Player* this, s32 item);
+void ChangeLantern(PlayState* play, Player* this);
+s32 Stasis(PlayState* play, Player* this);
+
+
 // .bss part 1
 static s32 D_80858AA0;
 static s32 D_80858AA4;
@@ -363,6 +373,17 @@ static Input* sControlInput;
 
 static u8 D_80853410[] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 };
 
+//MY VARIABLES
+int numJumps = 0;
+int jump3timer = 0;
+bool isGliding = false;
+int glideResetTimer = 0;
+bool landedAfterGliding = true;
+int lanternType = 0;
+int actionButtonTimer = 0;
+int personalUpdraftTimer = 0;
+
+
 static PlayerAgeProperties sAgeProperties[] = {
     {
         56.0f,
@@ -1062,6 +1083,22 @@ static s8 sItemActionParams[] = {
     PLAYER_IA_BOOTS_KOKIRI,
     PLAYER_IA_BOOTS_IRON,
     PLAYER_IA_BOOTS_HOVER,
+    PLAYER_IA_JUMP,
+    PLAYER_IA_GLIDER,
+    PLAYER_IA_LANTERN,
+    PLAYER_IA_STASIS,
+    PLAYER_IA_CUSTOM_MAX,
+    PLAYER_IA_MAX,
+};
+
+//CUSTOM
+static s8 sItemActionParamsCustom[] = {
+        PLAYER_IA_JUMP,
+    PLAYER_IA_GLIDER,
+    PLAYER_IA_LANTERN,
+    PLAYER_IA_STASIS,
+    PLAYER_IA_CUSTOM_MAX,
+    PLAYER_IA_MAX,
 };
 
 static u8 sMaskMemory;
@@ -1080,21 +1117,23 @@ static s32 (*D_80853EDC[])(Player* this, PlayState* play) = {
     func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C,
     func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C,
     func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C,
-    func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C,
+    func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C, func_8083485C,
+    func_8083485C, func_8083485C, func_8083485C,
 };
 
 static void (*D_80853FE8[])(PlayState* play, Player* this) = {
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_8083377C,
-    func_80833790, func_8083379C, func_8083379C, func_8083379C, func_8083379C, func_8083379C, func_8083379C,
-    func_8083379C, func_8083379C, func_80833910, func_80833910, func_808337D4, func_808337D4, func_80833984,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
-    func_80833770, func_80833770, func_80833770, func_80833770, func_80833770, func_80833770,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, func_8083377C,
+    ItemDoNothing2, ItemSlingshotOrAnyBow, ItemSlingshotOrAnyBow, ItemSlingshotOrAnyBow, ItemSlingshotOrAnyBow, ItemSlingshotOrAnyBow, ItemSlingshotOrAnyBow,
+    ItemSlingshotOrAnyBow, ItemSlingshotOrAnyBow, ItemSpawnHookshot, ItemSpawnHookshot, ItemSpawnBomb, ItemSpawnBomb, ItemBoomerangInHand,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
+    ItemDoNothing, ItemDoNothing, ItemDoNothing, ItemDoNothing,
 };
 
 typedef enum {
@@ -1711,7 +1750,7 @@ void func_8083328C(PlayState* play, Player* this, LinkAnimationHeader* linkAnim)
     LinkAnimation_PlayOnceSetSpeed(play, &this->skelAnime, linkAnim, D_808535E8);
 }
 
-s32 func_808332B8(Player* this) {
+s32 PlayerIsInWaterWithoutIronBootsOn(Player* this) {
     return (this->stateFlags1 & PLAYER_STATE1_IN_WATER) && (this->currentBoots != PLAYER_BOOTS_IRON);
 }
 
@@ -1832,7 +1871,7 @@ void func_80833664(PlayState* play, Player* this, s8 actionParam) {
         iter += ARRAY_COUNT(D_80853914[0]);
     }
 
-    func_8083399C(play, this, actionParam);
+    func_8083399C(play, this, actionParam); //only thing important in this function?
 
     if (i < ARRAY_COUNT(D_80853914)) {
         // fake match
@@ -1846,24 +1885,31 @@ s8 Player_ItemToItemAction(s32 item) {
         return PLAYER_IA_NONE;
     } else if (item == ITEM_LAST_USED) {
         return PLAYER_IA_LAST_USED;
-    } else if (item == ITEM_FISHING_POLE) {
+    }
+    else if (item == ITEM_FISHING_POLE) {
         return PLAYER_IA_FISHING_POLE;
-    } else {
+    }
+    else if (item >= ITEM_JUMP) {  //CUSTOM
+        int offset = PLAYER_IA_JUMP - ITEM_JUMP;
+
+        return sItemActionParamsCustom[item - ITEM_JUMP];
+    }
+     else {
         return sItemActionParams[item];
     }
 }
 
-void func_80833770(PlayState* play, Player* this) {
+void ItemDoNothing(PlayState* play, Player* this) {
 }
 
 void func_8083377C(PlayState* play, Player* this) {
     this->unk_85C = 1.0f;
 }
 
-void func_80833790(PlayState* play, Player* this) {
+void ItemDoNothing2(PlayState* play, Player* this) {
 }
 
-void func_8083379C(PlayState* play, Player* this) {
+void ItemSlingshotOrAnyBow(PlayState* play, Player* this) {
     this->stateFlags1 |= PLAYER_STATE1_ITEM_IN_HAND;
 
     if (this->heldItemAction != PLAYER_IA_SLINGSHOT) {
@@ -1873,7 +1919,7 @@ void func_8083379C(PlayState* play, Player* this) {
     }
 }
 
-void func_808337D4(PlayState* play, Player* this) {
+void ItemSpawnBomb(PlayState* play, Player* this) {
     s32 explosiveType;
     ExplosiveInfo* explosiveInfo;
     Actor* spawnedActor;
@@ -1910,7 +1956,8 @@ void func_808337D4(PlayState* play, Player* this) {
     }
 }
 
-void func_80833910(PlayState* play, Player* this) {
+//Spawn Hookshot as Child of Link
+void ItemSpawnHookshot(PlayState* play, Player* this) {
     this->stateFlags1 |= PLAYER_STATE1_ITEM_IN_HAND;
     this->unk_860 = -3;
 
@@ -1919,7 +1966,7 @@ void func_80833910(PlayState* play, Player* this) {
                            this->actor.world.pos.y, this->actor.world.pos.z, 0, this->actor.shape.rot.y, 0, 0);
 }
 
-void func_80833984(PlayState* play, Player* this) {
+void ItemBoomerangInHand(PlayState* play, Player* this) {
     this->stateFlags1 |= PLAYER_STATE1_BOOMERANG_IN_HAND;
 }
 
@@ -1932,10 +1979,14 @@ void func_8083399C(PlayState* play, Player* this, s8 actionParam) {
     this->modelGroup = this->nextModelGroup;
 
     this->stateFlags1 &= ~(PLAYER_STATE1_ITEM_IN_HAND | PLAYER_STATE1_BOOMERANG_IN_HAND);
-
-    D_80853FE8[actionParam](play, this);
-
-    Player_SetModelGroup(this, this->modelGroup);
+    //CUSTOM
+    if (actionParam != PLAYER_IA_STASIS) {
+        D_80853FE8[actionParam](play, this);
+    }
+    else {
+        ItemSlingshotOrAnyBow(play, this);
+    }
+        Player_SetModelGroup(this, this->modelGroup);
 }
 
 void func_80833A20(Player* this, s32 newSwordState) {
@@ -1976,7 +2027,7 @@ void func_80833A20(Player* this, s32 newSwordState) {
     this->meleeWeaponState = newSwordState;
 }
 
-s32 func_80833B2C(Player* this) {
+s32 Is_AttemptingZTarget(Player* this) {
     if (this->stateFlags1 & (PLAYER_STATE1_TARGET_LOCKED | PLAYER_STATE1_TARGET_NOTHING | PLAYER_STATE1_30)) {
         return 1;
     } else {
@@ -1985,7 +2036,7 @@ s32 func_80833B2C(Player* this) {
 }
 
 s32 func_80833B54(Player* this) {
-    if ((this->unk_664 != NULL) && CHECK_FLAG_ALL(this->unk_664->flags, ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_HOSTILE)) {
+    if ((this->targetActorMaybe != NULL) && CHECK_FLAG_ALL(this->targetActorMaybe->flags, ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_HOSTILE)) {
         this->stateFlags1 |= PLAYER_STATE1_ENEMY_TARGET;
         return 1;
     }
@@ -2000,12 +2051,12 @@ s32 func_80833B54(Player* this) {
     return 0;
 }
 
-s32 func_80833BCC(Player* this) {
-    return func_8008E9C4(this) || func_80833B2C(this);
+s32 Is_AttemptingToTargetOrTargetingEnemy(Player* this) {
+    return Is_PLAYER_STATE1_ENEMY_TARGET(this) || Is_AttemptingZTarget(this);
 }
 
 s32 func_80833C04(Player* this) {
-    return func_80833B54(this) || func_80833B2C(this);
+    return func_80833B54(this) || Is_AttemptingZTarget(this);
 }
 
 void func_80833C3C(Player* this) {
@@ -2121,14 +2172,17 @@ void func_80833DF8(Player* this, PlayState* play) {
             if ((item < ITEM_NONE_FE) && (Player_ItemToItemAction(item) == this->heldItemAction)) {
                 D_80853618 = true;
             }
+            //CUSTOM
+            ContinueItemAction(play, this, item); // continue item action if button held
         } else {
             this->heldItemButton = i;
-            func_80835F44(play, this, item);
+            func_80835F44(play, this, item); //do item action if button just pressed
+            actionButtonTimer = 0;
         }
     }
 }
 
-void func_808340DC(Player* this, PlayState* play) {
+void StartPutAwayItem(Player* this, PlayState* play) { //stasis is not getting here on take out or put away
     LinkAnimationHeader* anim;
     f32 frameCount;
     f32 startFrame;
@@ -2177,7 +2231,7 @@ void func_808340DC(Player* this, PlayState* play) {
     this->stateFlags1 &= ~PLAYER_STATE1_START_PUTAWAY;
 }
 
-void func_80834298(Player* this, PlayState* play) {
+void func_80834298(Player* this, PlayState* play) { //GOES WRONG FROM HERE?
     if ((this->actor.category == ACTORCAT_PLAYER) && (CVarGetInteger("gQuickPutaway", 0) || !(this->stateFlags1 & PLAYER_STATE1_START_PUTAWAY)) &&
         ((this->heldItemAction == this->itemAction) || (this->stateFlags1 & PLAYER_STATE1_SHIELDING)) &&
         (gSaveContext.health != 0) && (play->csCtx.state == CS_STATE_IDLE) && (this->csMode == 0) &&
@@ -2187,7 +2241,7 @@ void func_80834298(Player* this, PlayState* play) {
     }
 
     if (this->stateFlags1 & PLAYER_STATE1_START_PUTAWAY) {
-        func_808340DC(this, play);
+        StartPutAwayItem(this, play);
     }
 }
 
@@ -2224,6 +2278,17 @@ s32 func_8083442C(Player* this, PlayState* play) {
     s32 arrowType;
     s32 magicArrowType;
 
+    if (this->customProjectile != NULL) {
+        if ((this->customProjectile->update == NULL) | ((this->customProjectile->id != ACTOR_CUSTOM_PROJECTILE))) {
+            this->customProjectile = NULL;
+            //return 0;
+        }
+    }
+    if (this->customProjectile != NULL) {
+        this->customProjectile->flags |= 1; //time to kill old projectile;
+        return 0;
+    }
+
     if ((this->heldItemAction >= PLAYER_IA_BOW_FIRE) && (this->heldItemAction <= PLAYER_IA_BOW_0E) &&
         (gSaveContext.magicState != MAGIC_STATE_IDLE)) {
         func_80078884(NA_SE_SY_ERROR);
@@ -2234,7 +2299,7 @@ s32 func_8083442C(Player* this, PlayState* play) {
         this->unk_834 = 14;
 
         if (this->unk_860 >= 0) {
-            Player_PlaySfx(&this->actor, D_80854398[ABS(this->unk_860) - 1]);
+            Player_PlaySfx(&this->actor, D_80854398[ABS(this->unk_860) - 1]); //pull back bowstring
 
             if (!Player_HoldsHookshot(this) && (func_80834380(play, this, &item, &arrowType) > 0)) {
                 magicArrowType = arrowType - ARROW_FIRE;
@@ -2244,10 +2309,19 @@ s32 func_8083442C(Player* this, PlayState* play) {
                         !Magic_RequestChange(play, sMagicArrowCosts[magicArrowType], MAGIC_CONSUME_NOW)) {
                         arrowType = ARROW_NORMAL;
                     }
-
-                    this->heldActor = Actor_SpawnAsChild(
-                        &play->actorCtx, &this->actor, play, ACTOR_EN_ARROW, this->actor.world.pos.x,
-                        this->actor.world.pos.y, this->actor.world.pos.z, 0, this->actor.shape.rot.y, 0, arrowType);
+                    if (this->heldItemAction != PLAYER_IA_STASIS) {
+                        this->heldActor = Actor_SpawnAsChild(
+                            &play->actorCtx, &this->actor, play, ACTOR_EN_ARROW, this->actor.world.pos.x,
+                            this->actor.world.pos.y, this->actor.world.pos.z, 0, this->actor.shape.rot.y, 0, arrowType);
+                    }
+                    else {
+                        if (this->customProjectile == NULL) {
+                            this->heldActor = Actor_SpawnAsChild(
+                                &play->actorCtx, &this->actor, play, ACTOR_CUSTOM_PROJECTILE, this->actor.world.pos.x,
+                                this->actor.world.pos.y, this->actor.world.pos.z, 0, this->actor.shape.rot.y, 0, PROJECTILE_NORMAL);
+                            this->customProjectile = this->heldActor;
+                        }
+                    }
                 }
             }
         }
@@ -2280,8 +2354,13 @@ void func_80834644(PlayState* play, Player* this) {
     if (func_80834A2C == this->func_82C) {
         func_80834594(play, this);
     }
-
-    func_80833638(this, D_80853EDC[this->heldItemAction]);
+    //CUSTOM
+    if (this->heldItemAction != PLAYER_IA_STASIS) {
+        func_80833638(this, D_80853EDC[this->heldItemAction]);
+    }
+    else {
+        func_80833638(this, func_8083501C);
+    }
     this->unk_834 = 0;
     this->unk_6AC = 0;
     func_808323B4(play, this);
@@ -2307,7 +2386,7 @@ s32 func_80834758(PlayState* play, Player* this) {
 
     if (!(this->stateFlags1 & (PLAYER_STATE1_SHIELDING | PLAYER_STATE1_ON_HORSE | PLAYER_STATE1_IN_CUTSCENE)) &&
         (play->shootingGalleryStatus == 0) && (this->heldItemAction == this->itemAction) &&
-        (this->currentShield != PLAYER_SHIELD_NONE) && !Player_IsChildWithHylianShield(this) && func_80833BCC(this) &&
+        (this->currentShield != PLAYER_SHIELD_NONE) && !Player_IsChildWithHylianShield(this) && Is_AttemptingToTargetOrTargetingEnemy(this) &&
         CHECK_BTN_ALL(sControlInput->cur.button, BTN_R)) {
 
         anim = func_808346C4(play, this);
@@ -2356,7 +2435,7 @@ void func_808348EC(PlayState* play, Player* this) {
 
 s32 func_8083499C(Player* this, PlayState* play) {
     if (this->stateFlags1 & PLAYER_STATE1_START_PUTAWAY) {
-        func_808340DC(this, play);
+        //StartPutAwayItem(this, play);
     } else {
         return 0;
     }
@@ -2377,7 +2456,13 @@ s32 func_80834A2C(Player* this, PlayState* play) {
         ((Player_ItemToItemAction(this->heldItemId) == this->heldItemAction) &&
          (D_80853614 = (D_80853614 ||
                         ((this->modelAnimType != PLAYER_ANIMTYPE_3) && (play->shootingGalleryStatus == 0)))))) {
-        func_80833638(this, D_80853EDC[this->heldItemAction]);
+        //CUSTOM
+        if (this->heldItemAction != PLAYER_IA_STASIS) {
+            func_80833638(this, D_80853EDC[this->heldItemAction]);
+        }
+        else {
+            func_80833638(this, func_8083501C);
+        }
         this->unk_834 = 0;
         this->unk_6AC = 0;
         D_80853618 = D_80853614;
@@ -2428,7 +2513,13 @@ s32 func_80834C74(Player* this, PlayState* play) {
     D_80853614 = D_80853618;
 
     if (D_80853614 || LinkAnimation_Update(play, &this->skelAnime2)) {
-        func_80833638(this, D_80853EDC[this->heldItemAction]);
+        //CUSTOM
+        if (this->heldItemAction != PLAYER_IA_STASIS) {
+            func_80833638(this, D_80853EDC[this->heldItemAction]);
+        }
+        else {
+            func_80833638(this, func_8083501C);
+        }
         LinkAnimation_PlayLoop(play, &this->skelAnime2, D_80853914[PLAYER_ANIMGROUP_wait][this->modelAnimType]);
         this->unk_6AC = 0;
         this->func_82C(this, play);
@@ -2440,29 +2531,31 @@ s32 func_80834C74(Player* this, PlayState* play) {
 
 s32 func_80834D2C(Player* this, PlayState* play) {
     LinkAnimationHeader* anim;
+        if (this->heldItemAction != PLAYER_IA_BOOMERANG) {
+            if (!func_8083442C(this, play)) {
+                return 0;
+            }
 
-    if (this->heldItemAction != PLAYER_IA_BOOMERANG) {
-        if (!func_8083442C(this, play)) {
-            return 0;
+            if (!Player_HoldsHookshot(this)) {
+                anim = &gPlayerAnim_link_bow_bow_ready;
+            }
+            else {
+                anim = &gPlayerAnim_link_hook_shot_ready;
+            }
+            LinkAnimation_PlayOnce(play, &this->skelAnime2, anim);
         }
-
-        if (!Player_HoldsHookshot(this)) {
-            anim = &gPlayerAnim_link_bow_bow_ready;
-        } else {
-            anim = &gPlayerAnim_link_hook_shot_ready;
+        else {
+            func_80833638(this, func_80835884);
+            this->unk_834 = 10;
+            LinkAnimation_PlayOnce(play, &this->skelAnime2, &gPlayerAnim_link_boom_throw_wait2waitR);
         }
-        LinkAnimation_PlayOnce(play, &this->skelAnime2, anim);
-    } else {
-        func_80833638(this, func_80835884);
-        this->unk_834 = 10;
-        LinkAnimation_PlayOnce(play, &this->skelAnime2, &gPlayerAnim_link_boom_throw_wait2waitR);
-    }
 
-    if (this->stateFlags1 & PLAYER_STATE1_ON_HORSE) {
-        func_80832284(play, this, &gPlayerAnim_link_uma_anim_walk);
-    } else if ((this->actor.bgCheckFlags & 1) && !func_80833B54(this)) {
-        func_80832284(play, this, D_80853914[PLAYER_ANIMGROUP_wait][this->modelAnimType]);
-    }
+        if (this->stateFlags1 & PLAYER_STATE1_ON_HORSE) {
+            func_80832284(play, this, &gPlayerAnim_link_uma_anim_walk);
+        }
+        else if ((this->actor.bgCheckFlags & 1) && !func_80833B54(this)) {
+            func_80832284(play, this, D_80853914[PLAYER_ANIMGROUP_wait][this->modelAnimType]);
+        }
 
     return 1;
 }
@@ -2482,10 +2575,10 @@ s32 func_80834E7C(PlayState* play) {
 
 s32 func_80834EB8(Player* this, PlayState* play) {
     if ((this->unk_6AD == 0) || (this->unk_6AD == 2)) {
-        if (func_80833BCC(this) || (Camera_CheckValidMode(Play_GetCamera(play, 0), 7) == 0)) {
+        if (Is_AttemptingToTargetOrTargetingEnemy(this) || (Camera_CheckValidMode(Play_GetCamera(play, 0), 7) == 0)) {
             return 1;
         }
-        this->unk_6AD = 2;
+       //if (this->heldItemAction != PLAYER_IA_STASIS) this->unk_6AD = 2; 
     }
 
     return 0;
@@ -2583,9 +2676,13 @@ s32 func_808351D4(Player* this, PlayState* play) {
     } else {
         sp2C = 1;
     }
-
-    Math_ScaledStepToS(&this->unk_6C0, 1200, 400);
-    this->unk_6AE |= 0x100;
+    if (this->heldItemAction == PLAYER_IA_STASIS) { //CUSTOM - How much link should tilt left or right while pulling back string
+        Math_ScaledStepToS(&this->readyToFireTorsoRotZ, -1200, 400);
+    }
+    else {
+        Math_ScaledStepToS(&this->readyToFireTorsoRotZ, 1200, 400);
+    }
+    this->unk_6AE |= PLAYER_STATE4_8READY_TO_FIRE;
 
     if ((this->unk_836 == 0) && (func_80833350(this) == 0) &&
         (this->skelAnime.animation == &gPlayerAnim_link_bow_side_walk)) {
@@ -2608,7 +2705,7 @@ s32 func_808351D4(Player* this, PlayState* play) {
         func_80833638(this, func_808353D8);
         if (this->unk_860 >= 0) {
             if (sp2C == 0) {
-                if (!func_808350A4(play, this)) {
+                if (!func_808350A4(play, this)) { //shoot
                     Player_PlaySfx(&this->actor, D_808543DC[ABS(this->unk_860) - 1]);
                 }
             } else if (this->actor.bgCheckFlags & 1) {
@@ -2618,7 +2715,7 @@ s32 func_808351D4(Player* this, PlayState* play) {
         this->unk_834 = 10;
         Player_ZeroSpeedXZ(this);
     } else {
-        this->stateFlags1 |= PLAYER_STATE1_READY_TO_FIRE;
+        this->stateFlags1 |= PLAYER_STATE1_READY_TO_FIRE; //bowstring currently pulled back
     }
 
     return 1;
@@ -2647,7 +2744,7 @@ s32 func_808353D8(Player* this, PlayState* play) {
             this->unk_834--;
         }
 
-        if (func_80833BCC(this) || (this->unk_6AD != 0) || (this->stateFlags1 & PLAYER_STATE1_FIRST_PERSON)) {
+        if (Is_AttemptingToTargetOrTargetingEnemy(this) || (this->unk_6AD != 0) || (this->stateFlags1 & PLAYER_STATE1_FIRST_PERSON)) {
             if (this->unk_834 == 0) {
                 this->unk_834++;
             }
@@ -2718,11 +2815,32 @@ s32 func_808356E8(Player* this, PlayState* play) {
             LinkAnimation_PlayLoop(play, &this->skelAnime2, &gPlayerAnim_link_normal_carryB_wait);
         }
 
+        if (heldActor != NULL) {
         if ((heldActor->id == ACTOR_EN_NIW) && (this->actor.velocity.y <= 0.0f)) {
             this->actor.minVelocityY = -2.0f;
             this->actor.gravity = -0.5f;
             this->fallStartHeight = this->actor.world.pos.y;
         }
+            if (heldActor->id == ACTOR_EN_GLIDER) {
+                EnGlider* glider = (EnGlider*)heldActor;
+                if (glider->inWindZone == false) {
+                    this->actor.minVelocityY = -2.0f;
+                    this->actor.gravity = -0.25f;
+                    this->fallStartHeight = this->actor.world.pos.y;
+                }
+                else {
+                    float max = 8.0f;
+                    this->actor.minVelocityY = -2.0f;
+                    float g = 10.0f * (1.0f / glider->wzDistY);
+                    if (g > max) g = max;
+                    if ((this->actor.velocity.y + g) > max) {
+                        g = max - this->actor.velocity.y;
+                    }
+                    this->actor.gravity = g;
+                    this->fallStartHeight = this->actor.world.pos.y;
+                }
+            }
+        }
 
         return 1;
     }
@@ -2788,17 +2906,17 @@ s32 func_808359FC(Player* this, PlayState* play) {
     } else if (LinkAnimation_OnFrame(&this->skelAnime2, 6.0f)) {
         f32 posX = (Math_SinS(this->actor.shape.rot.y) * 10.0f) + this->actor.world.pos.x;
         f32 posZ = (Math_CosS(this->actor.shape.rot.y) * 10.0f) + this->actor.world.pos.z;
-        s32 yaw = (this->unk_664 != NULL) ? this->actor.shape.rot.y + 14000 : this->actor.shape.rot.y;
+        s32 yaw = (this->targetActorMaybe != NULL) ? this->actor.shape.rot.y + 14000 : this->actor.shape.rot.y;
         EnBoom* boomerang =
             (EnBoom*)Actor_Spawn(&play->actorCtx, play, ACTOR_EN_BOOM, posX, this->actor.world.pos.y + 30.0f,
                                  posZ, this->actor.focus.rot.x, yaw, 0, 0, true);
 
         this->boomerangActor = &boomerang->actor;
         if (boomerang != NULL) {
-            boomerang->moveTo = this->unk_664;
+            boomerang->moveTo = this->targetActorMaybe;
             boomerang->returnTimer = 20;
             this->stateFlags1 |= PLAYER_STATE1_THREW_BOOMERANG;
-            if (!func_8008E9C4(this)) {
+            if (!Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                 func_808355DC(this);
             }
             this->unk_A73 = 4;
@@ -2923,7 +3041,8 @@ void func_80835E44(PlayState* play, s16 camSetting) {
         if (camSetting == CAM_SET_SCENE_TRANSITION) {
             Interface_ChangeAlpha(2);
         }
-    } else {
+    }
+    else {
         Camera_ChangeSetting(Play_GetCamera(play, 0), camSetting);
     }
 }
@@ -2945,11 +3064,12 @@ void func_80835EFC(Player* this) {
     }
 }
 
-void func_80835F44(PlayState* play, Player* this, s32 item) {
+void func_80835F44(PlayState* play, Player* this, s32 item) { //just pressed button item action
     s8 actionParam;
     s32 temp;
     s32 nextAnimType;
 
+    //if (item < 0) return;
     actionParam = Player_ItemToItemAction(item);
 
     if (((this->heldItemAction == this->itemAction) &&
@@ -2972,22 +3092,61 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
                 func_80078884(NA_SE_SY_ERROR);
                 return;
             }
+            if (actionParam == PLAYER_IA_JUMP) {
+                SSBJump(play, this);
+                return;
+            }
+            if (actionParam == PLAYER_IA_GLIDER) {
+                Glide(play, this);
+                return;
+            }
+            if (actionParam == PLAYER_IA_LANTERN) {
+                Lantern(play, this);
+                return;
+            }
+            if (actionParam == PLAYER_IA_STASIS) {
+                if (actionParam != this->heldItemAction) {
 
-            if (actionParam >= PLAYER_IA_SHIELD_DEKU) {
-                // Changing shields through action commands is unimplemented
-                // Boots and tunics handled previously
+                    this->nextModelGroup = Player_ActionToModelGroup(this, actionParam);
+                    nextAnimType = gPlayerModelTypes[this->nextModelGroup][PLAYER_MODELGROUPENTRY_ANIM];
+
+                    if ((this->heldItemAction >= 0) &&
+                        (item != this->heldItemId) &&
+                        (D_80854164[gPlayerModelTypes[this->modelGroup][PLAYER_MODELGROUPENTRY_ANIM]][nextAnimType] !=
+                            PLAYER_D_808540F4_0)) {
+                        this->heldItemId = item;
+                        this->stateFlags1 |= PLAYER_STATE1_START_PUTAWAY;
+                    }
+                    else {
+                        func_80835EFC(this); //HeldActor stuff
+                        func_808323B4(play, this); //HeldActor stuff
+                        func_80833664(play, this, actionParam);
+                    }
+                    return;
+                }
+                D_80853614 = D_80853618 = true;
                 return;
+                //Stasis(play, this);
+
             }
+            if (actionParam < PLAYER_IA_JUMP) {
+            //if (actionParam >= PLAYER_IA_SHIELD_DEKU) {
+                // Changing shields through action commands is unimplemented
+                // Boots and tunics handled previously
+            //    return;
+           // }
 
             if (actionParam == PLAYER_IA_LENS_OF_TRUTH) {
                 if (Magic_RequestChange(play, 0, MAGIC_CONSUME_LENS)) {
                     if (play->actorCtx.lensActive) {
                         Actor_DisableLens(play);
-                    } else {
+                        }
+                        else {
                         play->actorCtx.lensActive = true;
                     }
                     func_80078884((play->actorCtx.lensActive) ? NA_SE_SY_GLASSMODE_ON : NA_SE_SY_GLASSMODE_OFF);
-                } else {
+                    }
+                    else {
                     func_80078884(NA_SE_SY_ERROR);
                 }
                 return;
@@ -2996,7 +3155,8 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
             if (actionParam == PLAYER_IA_DEKU_NUT) {
                 if (AMMO(ITEM_NUT) != 0) {
                     func_8083C61C(play, this);
-                } else {
+                    }
+                    else {
                     func_80078884(NA_SE_SY_ERROR);
                 }
                 return;
@@ -3009,7 +3169,8 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
                      (gSaveContext.magic >= sMagicSpellCosts[temp]))) {
                     this->itemAction = actionParam;
                     this->unk_6AD = 4;
-                } else {
+                    }
+                    else {
                     func_80078884(NA_SE_SY_ERROR);
                 }
                 return;
@@ -3018,7 +3179,8 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
             if (actionParam >= PLAYER_IA_MASK_KEATON) {
                 if (this->currentMask != PLAYER_MASK_NONE) {
                     this->currentMask = PLAYER_MASK_NONE;
-                } else {
+                    }
+                    else {
                     this->currentMask = actionParam - PLAYER_IA_MASK_KEATON + 1;
                 }
                 sMaskMemory = this->currentMask;
@@ -3028,7 +3190,7 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
 
             if (((actionParam >= PLAYER_IA_OCARINA_FAIRY) && (actionParam <= PLAYER_IA_OCARINA_OF_TIME)) ||
                 (actionParam >= PLAYER_IA_BOTTLE_FISH)) {
-                if (!func_8008E9C4(this) ||
+                if (!Is_PLAYER_STATE1_ENEMY_TARGET(this) ||
                     ((actionParam >= PLAYER_IA_BOTTLE_POTION_RED) && (actionParam <= PLAYER_IA_BOTTLE_FAIRY))) {
                     func_8002D53C(play, &play->actorCtx.titleCtx);
                     this->unk_6AD = 4;
@@ -3036,11 +3198,14 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
                 }
                 return;
             }
+            }
 
             if ((actionParam != this->heldItemAction) ||
                 ((this->heldActor == 0) && (Player_ActionToExplosive(this, actionParam) >= 0))) {
+
                 this->nextModelGroup = Player_ActionToModelGroup(this, actionParam);
                 nextAnimType = gPlayerModelTypes[this->nextModelGroup][PLAYER_MODELGROUPENTRY_ANIM];
+
                 if ((this->heldItemAction >= 0) && (Player_ActionToMagicSpell(this, actionParam) < 0) &&
                     (item != this->heldItemId) &&
                     (D_80854164[gPlayerModelTypes[this->modelGroup][PLAYER_MODELGROUPENTRY_ANIM]][nextAnimType] !=
@@ -3051,20 +3216,53 @@ void func_80835F44(PlayState* play, Player* this, s32 item) {
                     this->heldItemId = item;
                     this->stateFlags1 |= PLAYER_STATE1_START_PUTAWAY;
                 } else {
-                    func_80835EFC(this);
-                    func_808323B4(play, this);
+                    func_80835EFC(this); //HeldActor stuff
+                    func_808323B4(play, this); //HeldActor stuff
                     func_80833664(play, this, actionParam);
                 }
                 return;
             }
-
             D_80853614 = D_80853618 = true;
         }
     }
 }
 
+void ContinueItemAction(PlayState* play, Player* this, s32 item) { //just pressed button item action
+    s8 actionParam;
+    s32 temp;
+    s32 nextAnimType;
+
+    actionParam = Player_ItemToItemAction(item);
+
+    if (((this->heldItemAction == this->itemAction) &&
+        (!(this->stateFlags1 & PLAYER_STATE1_SHIELDING) || (Player_ActionToMeleeWeapon(actionParam) != 0) ||
+            (actionParam == PLAYER_IA_NONE))) ||
+        ((this->itemAction < 0) &&
+            ((Player_ActionToMeleeWeapon(actionParam) != 0) || (actionParam == PLAYER_IA_NONE)))) {
+
+        if (!(this->stateFlags1 & PLAYER_STATE1_IN_WATER)) { //if not in water
+            if (actionParam == PLAYER_IA_JUMP) {
+                //SSBJump(play, this);
+                return;
+            }
+            if (actionParam == PLAYER_IA_GLIDER) {
+                //Glide(play, this); //if just pressed
+                SpawnWindZone(play, this);
+                return;
+            }
+            if (actionParam == PLAYER_IA_LANTERN) {
+                ChangeLantern(play, this);
+                return;
+            }
+            if (actionParam == PLAYER_IA_STASIS) {
+                return;
+            }
+        }
+    }
+}
+
 void func_80836448(PlayState* play, Player* this, LinkAnimationHeader* anim) {
-    s32 cond = func_808332B8(this);
+    s32 cond = PlayerIsInWaterWithoutIronBootsOn(this);
 
     func_80832564(play, this);
 
@@ -3117,13 +3315,15 @@ s32 func_80836670(Player* this, PlayState* play) {
         this->currentYaw = this->actor.shape.rot.y;
         this->actor.bgCheckFlags &= ~1;
         this->hoverBootsTimer = 0;
-        this->unk_6AE |= 0x43;
+        this->unk_6AE |= PLAYER_STATE4_6;
+        this->unk_6AE |= PLAYER_STATE4_1FIRST_PERSON_AND_MORE;
+        this->unk_6AE |= PLAYER_STATE4_0;
         func_80832698(this, NA_SE_VO_LI_LASH);
         return 1;
     }
 
-    if (func_808365C8(this)) {
-        func_80834298(this, play);
+    if (func_808365C8(this)) { //check to see if in PUTAWAY animation?
+        func_80834298(this, play); //Do Item Action Stuff
         if (func_8084E604 == this->func_674) {
             return 1;
         }
@@ -3154,7 +3354,7 @@ s32 func_80836670(Player* this, PlayState* play) {
 
 s32 func_80836898(PlayState* play, Player* this, PlayerFuncA74 func) {
     this->func_A74 = func;
-    func_80835C58(play, this, func_808458D0, 0);
+    func_80835C58(play, this, func_808458D0, 0); //this? 1
     this->stateFlags2 |= PLAYER_STATE2_DISABLE_ROTATION_ALWAYS;
     return func_80832528(play, this);
 }
@@ -3163,18 +3363,19 @@ void func_808368EC(Player* this, PlayState* play) {
     s16 previousYaw = this->actor.shape.rot.y;
 
     if (!(this->stateFlags2 & (PLAYER_STATE2_DISABLE_ROTATION_Z_TARGET | PLAYER_STATE2_DISABLE_ROTATION_ALWAYS))) {
-        if ((this->unk_664 != NULL) &&
+        if ((this->targetActorMaybe != NULL) &&
             ((play->actorCtx.targetCtx.unk_4B != 0) || (this->actor.category != ACTORCAT_PLAYER))) {
             Math_ScaledStepToS(&this->actor.shape.rot.y,
-                               Math_Vec3f_Yaw(&this->actor.world.pos, &this->unk_664->focus.pos), 4000);
+                               Math_Vec3f_Yaw(&this->actor.world.pos, &this->targetActorMaybe->focus.pos), 4000);
         } else if ((this->stateFlags1 & PLAYER_STATE1_TARGET_NOTHING) &&
                    !(this->stateFlags2 & (PLAYER_STATE2_DISABLE_ROTATION_Z_TARGET | PLAYER_STATE2_DISABLE_ROTATION_ALWAYS))) {
             Math_ScaledStepToS(&this->actor.shape.rot.y, this->targetYaw, 4000);
         }
     } else if (!(this->stateFlags2 & PLAYER_STATE2_DISABLE_ROTATION_ALWAYS)) {
-        Math_ScaledStepToS(&this->actor.shape.rot.y, this->currentYaw, 2000);
+        Math_ScaledStepToS(&this->actor.shape.rot.y, this->currentYaw, 2000); //rotate Link on Y axis while already walking or running
     }
 
+    //Turn rate - probably for how much Link should lean while running
     this->unk_87C = this->actor.shape.rot.y - previousYaw;
 }
 
@@ -3205,24 +3406,29 @@ s32 func_80836AB8(Player* this, s32 arg1) {
     var = this->actor.shape.rot.y;
     if (arg1 != 0) {
         var = this->actor.focus.rot.y;
-        this->unk_6BC = this->actor.focus.rot.x;
-        this->unk_6AE |= 0x41;
+        this->runningTorsoForwardRotation = this->actor.focus.rot.x;
+        this->unk_6AE |= PLAYER_STATE4_6;
+        this->unk_6AE |= PLAYER_STATE4_0;
     } else {
-        func_808369C8(&this->unk_6BC,
-                      func_808369C8(&this->unk_6B6, this->actor.focus.rot.x, 600, 10000, this->actor.focus.rot.x, 0),
-                      200, 4000, this->unk_6B6, 10000);
+        func_808369C8(&this->runningTorsoForwardRotation,
+                      func_808369C8(&this->runningHeadForwardRotation, this->actor.focus.rot.x, 600, 10000, this->actor.focus.rot.x, 0),
+                      200, 4000, this->runningHeadForwardRotation, 10000);
         sp36 = this->actor.focus.rot.y - var;
         func_808369C8(&sp36, 0, 200, 24000, this->unk_6BE, 8000);
         var = this->actor.focus.rot.y - sp36;
-        func_808369C8(&this->unk_6B8, sp36 - this->unk_6BE, 200, 8000, sp36, 8000);
-        func_808369C8(&this->unk_6BE, sp36, 200, 8000, this->unk_6B8, 8000);
-        this->unk_6AE |= 0xD9;
+        func_808369C8(&this->focusHeadYRotation, sp36 - this->unk_6BE, 200, 8000, sp36, 8000);
+        func_808369C8(&this->unk_6BE, sp36, 200, 8000, this->focusHeadYRotation, 8000);
+        this->unk_6AE |= PLAYER_STATE4_7;
+        this->unk_6AE |= PLAYER_STATE4_6;
+        this->unk_6AE |= PLAYER_STATE4_4FOCUS_HEAD_ROTATION_Y;
+        this->unk_6AE |= PLAYER_STATE4_3;
+        this->unk_6AE |= PLAYER_STATE4_0;
     }
 
     return var;
 }
 
-void func_80836BEC(Player* this, PlayState* play) {
+void UpdateZButtonHeldOrAlreadyLockedOn(Player* this, PlayState* play) {
     s32 sp1C = 0;
     s32 zTrigPressed = CHECK_BTN_ALL(sControlInput->cur.button, BTN_Z);
     Actor* actorToTarget;
@@ -3232,6 +3438,16 @@ void func_80836BEC(Player* this, PlayState* play) {
 
     if (!zTrigPressed) {
         this->stateFlags1 &= ~PLAYER_STATE1_30;
+        this->thirdPersonAiming = false;
+    }
+    else {
+        //CUSTOM
+        if ((this->heldItemAction == PLAYER_IA_STASIS)) {
+            this->thirdPersonAiming = true;
+        }
+        else {
+            this->thirdPersonAiming = false;
+        }
     }
 
     if ((play->csCtx.state != CS_STATE_IDLE) || (this->csMode != 0) ||
@@ -3270,15 +3486,15 @@ void func_80836BEC(Player* this, PlayState* play) {
                 this->stateFlags1 |= PLAYER_STATE1_TARGETING;
 
                 if ((actorToTarget != NULL) && !(actorToTarget->flags & ACTOR_FLAG_NO_LOCKON)) {
-                    if ((actorToTarget == this->unk_664) && (this->actor.category == ACTORCAT_PLAYER)) {
+                    if ((actorToTarget == this->targetActorMaybe) && (this->actor.category == ACTORCAT_PLAYER)) {
                         actorToTarget = play->actorCtx.targetCtx.unk_94;
                     }
 
-                    if (actorToTarget != this->unk_664) {
+                    if (actorToTarget != this->targetActorMaybe) {
                         if (!holdTarget) {
                             this->stateFlags2 |= PLAYER_STATE2_SWITCH_TARGETING;
                         }
-                        this->unk_664 = actorToTarget;
+                        this->targetActorMaybe = actorToTarget;
                         this->unk_66C = 15;
                         this->stateFlags2 &= ~(PLAYER_STATE2_SPEAK_OR_CHECK | PLAYER_STATE2_NAVI_ALERT);
                     } else {
@@ -3295,23 +3511,23 @@ void func_80836BEC(Player* this, PlayState* play) {
                 }
             }
 
-            if (this->unk_664 != NULL) {
-                if ((this->actor.category == ACTORCAT_PLAYER) && (this->unk_664 != this->unk_684) &&
-                    func_8002F0C8(this->unk_664, this, sp1C)) {
+            if (this->targetActorMaybe != NULL) {
+                if ((this->actor.category == ACTORCAT_PLAYER) && (this->targetActorMaybe != this->unk_684) &&
+                    func_8002F0C8(this->targetActorMaybe, this, sp1C)) {
                     func_8008EDF0(this);
                     this->stateFlags1 |= PLAYER_STATE1_30;
-                } else if (this->unk_664 != NULL) {
-                    this->unk_664->targetPriority = 40;
+                } else if (this->targetActorMaybe != NULL) {
+                    this->targetActorMaybe->targetPriority = 40;
                 }
             } else if (this->unk_684 != NULL) {
-                this->unk_664 = this->unk_684;
+                this->targetActorMaybe = this->unk_684;
             }
         }
 
-        if (this->unk_664 != NULL) {
+        if (this->targetActorMaybe != NULL) {
             this->stateFlags1 &= ~(PLAYER_STATE1_TARGET_LOCKED | PLAYER_STATE1_TARGET_NOTHING);
             if ((this->stateFlags1 & PLAYER_STATE1_ITEM_OVER_HEAD) ||
-                !CHECK_FLAG_ALL(this->unk_664->flags, ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_HOSTILE)) {
+                !CHECK_FLAG_ALL(this->targetActorMaybe->flags, ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_HOSTILE)) {
                 this->stateFlags1 |= PLAYER_STATE1_TARGET_LOCKED;
             }
         } else {
@@ -3381,12 +3597,12 @@ s32 func_80837268(Player* this, f32* arg1, s16* arg2, f32 arg3, PlayState* play)
     if (!func_80836FAC(play, this, arg1, arg2, arg3)) {
         *arg2 = this->actor.shape.rot.y;
 
-        if (this->unk_664 != NULL) {
+        if (this->targetActorMaybe != NULL) {
             if ((play->actorCtx.targetCtx.unk_4B != 0) && !(this->stateFlags2 & PLAYER_STATE2_DISABLE_ROTATION_ALWAYS)) {
-                *arg2 = Math_Vec3f_Yaw(&this->actor.world.pos, &this->unk_664->focus.pos);
+                *arg2 = Math_Vec3f_Yaw(&this->actor.world.pos, &this->targetActorMaybe->focus.pos);
                 return 0;
             }
-        } else if (func_80833B2C(this)) {
+        } else if (Is_AttemptingZTarget(this)) {
             *arg2 = this->targetYaw;
         }
 
@@ -3426,7 +3642,8 @@ s32 func_80837348(PlayState* play, Player* this, s8* arg2, s32 arg3) {
         }
 
         if (func_8008F128(this)) {
-            this->unk_6AE |= 0x41;
+            this->unk_6AE |= PLAYER_STATE4_6;
+            this->unk_6AE |= PLAYER_STATE4_0;
             return 1;
         }
 
@@ -3437,7 +3654,6 @@ s32 func_80837348(PlayState* play, Player* this, s8* arg2, s32 arg3) {
                 }
                 arg2++;
             }
-
             if (D_80854448[-(*arg2)](this, play)) {
                 return 1;
             }
@@ -3533,7 +3749,7 @@ void func_80837704(PlayState* play, Player* this) {
 }
 
 void func_808377DC(PlayState* play, Player* this) {
-    func_80835C58(play, this, func_80844E68, 1);
+    func_80835C58(play, this, func_80844E68, 1); //this? probably sword stuff
     func_80837704(play, this);
 }
 
@@ -3555,7 +3771,7 @@ s32 func_80837818(Player* this) {
             sp18 = 24;
         } else {
             if (sp1C < 0) {
-                if (func_80833BCC(this)) {
+                if (Is_AttemptingToTargetOrTargetingEnemy(this)) {
                     sp18 = 0;
                 } else {
                     sp18 = 4;
@@ -3564,7 +3780,7 @@ s32 func_80837818(Player* this) {
                 sp18 = D_80854480[sp1C];
                 if (sp18 == 12) {
                     this->stateFlags2 |= PLAYER_STATE2_SWORD_LUNGE;
-                    if (!func_80833BCC(this)) {
+                    if (!Is_AttemptingToTargetOrTargetingEnemy(this)) {
                         sp18 = 0;
                     }
                 }
@@ -3789,7 +4005,7 @@ void func_80837C0C(PlayState* play, Player* this, s32 arg2, f32 arg3, f32 arg4,
             this->hoverBootsTimer = 0;
             this->actor.bgCheckFlags &= ~1;
         } else {
-            if ((this->linearVelocity > 4.0f) && !func_8008E9C4(this)) {
+            if ((this->linearVelocity > 4.0f) && !Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                 this->unk_890 = 20;
                 Player_RequestRumble(this, 120, 20, 10, 0);
                 func_80832698(this, NA_SE_VO_LI_DAMAGE_S);
@@ -3813,7 +4029,7 @@ void func_80837C0C(PlayState* play, Player* this, s32 arg2, f32 arg3, f32 arg4,
                 sp28 += 2;
             }
 
-            if (func_8008E9C4(this)) {
+            if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                 sp28 += 1;
             }
 
@@ -3958,7 +4174,7 @@ s32 func_808382DC(Player* this, PlayState* play) {
                         LinkAnimationHeader* anim;
                         s32 sp54 = func_80843188 == this->func_674;
 
-                        if (!func_808332B8(this)) {
+                        if (!PlayerIsInWaterWithoutIronBootsOn(this)) {
                             func_80835C58(play, this, func_808435C4, 0);
                         }
 
@@ -4051,6 +4267,7 @@ s32 func_808382DC(Player* this, PlayState* play) {
 }
 
 void func_80838940(Player* this, LinkAnimationHeader* anim, f32 arg2, PlayState* play, u16 sfxId) {
+    numJumps++; // Autojump counts as first manual jump
     func_80835C58(play, this, func_8084411C, 1);
 
     if (anim != NULL) {
@@ -4084,7 +4301,7 @@ s32 func_80838A14(Player* this, PlayState* play) {
         (!(this->stateFlags1 & PLAYER_STATE1_IN_WATER) || (this->ageProperties->unk_14 > this->wallHeight))) {
         sp3C = 0;
 
-        if (func_808332B8(this)) {
+        if (PlayerIsInWaterWithoutIronBootsOn(this)) {
             if (this->actor.yDistToWater < 50.0f) {
                 if ((this->unk_88C < 2) || (this->wallHeight > this->ageProperties->unk_10)) {
                     return 0;
@@ -4125,7 +4342,7 @@ s32 func_80838A14(Player* this, PlayState* play) {
 
                 this->stateFlags1 |= PLAYER_STATE1_CLIMBING_LEDGE;
 
-                if (func_808332B8(this)) {
+                if (PlayerIsInWaterWithoutIronBootsOn(this)) {
                     sp38 = &gPlayerAnim_link_swimer_swim_15step_up;
                     sp34 -= (60.0f * this->ageProperties->unk_08);
                     this->stateFlags1 &= ~PLAYER_STATE1_IN_WATER;
@@ -4167,7 +4384,7 @@ s32 func_80838A14(Player* this, PlayState* play) {
 }
 
 void func_80838E70(PlayState* play, Player* this, f32 arg2, s16 arg3) {
-    func_80835C58(play, this, func_80845CA4, 0);
+    func_80835C58(play, this, func_80845CA4, 0); //this? probably door cutscene stuff
     func_80832440(play, this);
 
     this->unk_84F = 1;
@@ -4284,7 +4501,7 @@ s32 func_80839034(PlayState* play, Player* this, CollisionPoly* poly, u32 bgId)
             }
 
             if (!(this->stateFlags1 & (PLAYER_STATE1_ON_HORSE | PLAYER_STATE1_IN_CUTSCENE)) &&
-                !(this->stateFlags2 & PLAYER_STATE2_CRAWLING) && !func_808332B8(this) &&
+                !(this->stateFlags2 & PLAYER_STATE2_CRAWLING) && !PlayerIsInWaterWithoutIronBootsOn(this) &&
                 (temp = func_80041D4C(&play->colCtx, poly, bgId), (temp != 10)) &&
                 ((sp34 < 100) || (this->actor.bgCheckFlags & 1))) {
 
@@ -4578,7 +4795,7 @@ s32 func_80839800(Player* this, PlayState* play) {
 void func_80839E88(Player* this, PlayState* play) {
     LinkAnimationHeader* anim;
 
-    func_80835C58(play, this, func_80840450, 1);
+    func_80835C58(play, this, func_80840450, 1); //this? lots of stuff 2
 
     if (this->unk_870 < 0.5f) {
         anim = func_808334E4(this);
@@ -4594,15 +4811,15 @@ void func_80839E88(Player* this, PlayState* play) {
 }
 
 void func_80839F30(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_808407CC, 1);
+    func_80835C58(play, this, func_808407CC, 1); //this? lots of stuff
     func_80832B0C(play, this, func_80833338(this));
     this->currentYaw = this->actor.shape.rot.y;
 }
 
 void func_80839F90(Player* this, PlayState* play) {
-    if (func_8008E9C4(this)) {
+    if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
         func_80839E88(this, play);
-    } else if (func_80833B2C(this)) {
+    } else if (Is_AttemptingZTarget(this)) {
         func_80839F30(this, play);
     } else {
         func_80853080(this, play);
@@ -4612,9 +4829,9 @@ void func_80839F90(Player* this, PlayState* play) {
 void func_80839FFC(Player* this, PlayState* play) {
     PlayerFunc674 func;
 
-    if (func_8008E9C4(this)) {
+    if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
         func = func_80840450;
-    } else if (func_80833B2C(this)) {
+    } else if (Is_AttemptingZTarget(this)) {
         func = func_808407CC;
     } else {
         func = func_80840BC8;
@@ -4625,7 +4842,7 @@ void func_80839FFC(Player* this, PlayState* play) {
 
 void func_8083A060(Player* this, PlayState* play) {
     func_80839FFC(this, play);
-    if (func_8008E9C4(this)) {
+    if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
         this->unk_850 = 1;
     }
 }
@@ -4694,7 +4911,7 @@ void func_8083A2F8(PlayState* play, Player* this) {
 
     if (this->actor.textId != 0) {
         Message_StartTextbox(play, this->actor.textId, this->targetActor);
-        this->unk_664 = this->targetActor;
+        this->targetActorMaybe = this->targetActor;
     }
 }
 
@@ -4703,7 +4920,7 @@ void func_8083A360(PlayState* play, Player* this) {
 }
 
 void func_8083A388(PlayState* play, Player* this) {
-    func_80835C58(play, this, func_8084B78C, 0);
+    func_80835C58(play, this, func_8084B78C, 0);  //this? push pull stuff
 }
 
 void func_8083A3B0(PlayState* play, Player* this) {
@@ -4765,7 +4982,7 @@ void func_8083A5C4(PlayState* play, Player* this, CollisionPoly* arg2, f32 arg3,
     f32 sp24 = COLPOLY_GET_NORMAL(arg2->normal.x);
     f32 sp20 = COLPOLY_GET_NORMAL(arg2->normal.z);
 
-    func_80835C58(play, this, func_8084BBE4, 0);
+    func_80835C58(play, this, func_8084BBE4, 0); //this? holding on to ledge or ladder stuff
     func_80832564(play, this);
     func_80832264(play, this, arg4);
 
@@ -4844,7 +5061,7 @@ s32 func_8083A6AC(Player* this, PlayState* play) {
 }
 
 void func_8083A9B8(Player* this, LinkAnimationHeader* anim, PlayState* play) {
-    func_80835C58(play, this, func_8084BDFC, 0);
+    func_80835C58(play, this, func_8084BDFC, 0); //this? climb up 
     LinkAnimation_PlayOnceSetSpeed(play, &this->skelAnime, anim, 1.3f);
 }
 
@@ -4927,8 +5144,8 @@ void func_8083AA10(Player* this, PlayState* play) {
 s32 func_8083AD4C(PlayState* play, Player* this) {
     s32 cameraMode;
 
-    if (this->unk_6AD == 2) {
-        if (func_8002DD6C(this)) {
+    if (this->unk_6AD == 2) { //LOOK HERE NEXT //this?
+        if (PlayerStateItemInHand(this)) {
             bool shouldUseBowCamera = LINK_IS_ADULT;
 
             if(CVarGetInteger("gBowSlingShotAmmoFix", 0)){
@@ -5001,8 +5218,8 @@ void func_8083AF44(PlayState* play, Player* this, s32 magicSpell) {
 }
 
 void func_8083B010(Player* this) {
-    this->actor.focus.rot.x = this->actor.focus.rot.z = this->unk_6B6 = this->unk_6B8 = this->unk_6BA = this->unk_6BC =
-        this->unk_6BE = this->unk_6C0 = 0;
+    this->actor.focus.rot.x = this->actor.focus.rot.z = this->runningHeadForwardRotation = this->focusHeadYRotation = this->runningHeadLeanRotation = this->runningTorsoForwardRotation =
+        this->unk_6BE = this->readyToFireTorsoRotZ = 0;
 
     this->actor.focus.rot.y = this->actor.shape.rot.y;
 }
@@ -5021,19 +5238,19 @@ static LinkAnimationHeader* D_80854548[] = {
     &gPlayerAnim_link_normal_take_out,
 };
 
-s32 func_8083B040(Player* this, PlayState* play) {
+s32 func_8083B040(Player* this, PlayState* play) { //not getting here consistently with stasis
     s32 sp2C;
     s32 sp28;
     GetItemEntry giEntry;
     Actor* targetActor;
 
     if ((this->unk_6AD != 0) &&
-        (func_808332B8(this) || (this->actor.bgCheckFlags & 1) || (this->stateFlags1 & PLAYER_STATE1_ON_HORSE))) {
+        (PlayerIsInWaterWithoutIronBootsOn(this) || (this->actor.bgCheckFlags & 1) || (this->stateFlags1 & PLAYER_STATE1_ON_HORSE))) {
 
         if (!func_8083ADD4(play, this)) {
             if (this->unk_6AD == 4) {
                 sp2C = Player_ActionToMagicSpell(this, this->itemAction);
-                if (sp2C >= 0) {
+                if (sp2C >= 0) { //if is a magic spell
                     if ((sp2C != 3) || (gSaveContext.respawn[RESPAWN_MODE_TOP].data <= 0)) {
                         func_8083AF44(play, this, sp2C);
                     } else {
@@ -5093,7 +5310,7 @@ s32 func_8083B040(Player* this, PlayState* play) {
                                 this->unk_84F = -1;
                             }
                             targetActor->flags |= ACTOR_FLAG_PLAYER_TALKED_TO;
-                            this->unk_664 = this->targetActor;
+                            this->targetActorMaybe = this->targetActor;
                         } else if (sp2C == EXCH_ITEM_LETTER_RUTO) {
                             this->unk_84F = 1;
                             this->actor.textId = 0x4005;
@@ -5145,11 +5362,13 @@ s32 func_8083B040(Player* this, PlayState* play) {
                 }
             } else if (func_8083AD4C(play, this)) {
                 if (!(this->stateFlags1 & PLAYER_STATE1_ON_HORSE)) {
-                    func_80835C58(play, this, func_8084B1D8, 1);
+                    func_80835C58(play, this, func_8084B1D8, 1); //this? VERY LIKELY
                     this->unk_850 = 13;
                     func_8083B010(this);
                 }
-                this->stateFlags1 |= PLAYER_STATE1_FIRST_PERSON;
+                if (this->heldItemAction != PLAYER_IA_STASIS) { //CUSTOM dont zoom in when equipping weapon
+                    this->stateFlags1 |= PLAYER_STATE1_FIRST_PERSON;
+                }
                 func_80078884(NA_SE_SY_CAMERA_ZOOM_UP);
                 Player_ZeroSpeedXZ(this);
                 return 1;
@@ -5171,7 +5390,7 @@ s32 func_8083B040(Player* this, PlayState* play) {
 
 s32 func_8083B644(Player* this, PlayState* play) {
     Actor* sp34 = this->targetActor;
-    Actor* sp30 = this->unk_664;
+    Actor* sp30 = this->targetActorMaybe;
     Actor* sp2C = NULL;
     s32 sp28 = 0;
     s32 sp24;
@@ -5197,7 +5416,7 @@ s32 func_8083B644(Player* this, PlayState* play) {
                 ((this->heldActor != NULL) && (sp28 || (sp34 == this->heldActor) || (sp2C == this->heldActor) ||
                                                ((sp34 != NULL) && (sp34->flags & ACTOR_FLAG_WILL_TALK))))) {
                 if ((this->actor.bgCheckFlags & 1) || (this->stateFlags1 & PLAYER_STATE1_ON_HORSE) ||
-                    (func_808332B8(this) && !(this->stateFlags2 & PLAYER_STATE2_UNDERWATER))) {
+                    (PlayerIsInWaterWithoutIronBootsOn(this) && !(this->stateFlags2 & PLAYER_STATE2_UNDERWATER))) {
 
                     if (sp34 != NULL) {
                         this->stateFlags2 |= PLAYER_STATE2_SPEAK_OR_CHECK;
@@ -5249,7 +5468,7 @@ s32 func_8083B8F4(Player* this, PlayState* play) {
     if (!(this->stateFlags1 & (PLAYER_STATE1_ITEM_OVER_HEAD | PLAYER_STATE1_ON_HORSE)) &&
         Camera_CheckValidMode(Play_GetCamera(play, 0), 6)) {
         if ((this->actor.bgCheckFlags & 1) ||
-            (func_808332B8(this) && (this->actor.yDistToWater < this->ageProperties->unk_2C))) {
+            (PlayerIsInWaterWithoutIronBootsOn(this) && (this->actor.yDistToWater < this->ageProperties->unk_2C))) {
             this->unk_6AD = 1;
             return 1;
         }
@@ -5259,15 +5478,15 @@ s32 func_8083B8F4(Player* this, PlayState* play) {
 }
 
 s32 func_8083B998(Player* this, PlayState* play) {
-    if (this->unk_6AD != 0) {
-        func_8083B040(this, play);
+    if (this->unk_6AD != 0) { //unk_6AD should == 2
+        func_8083B040(this, play); //THIS NEXT
         return 1;
     }
 
-    if ((this->unk_664 != NULL) &&
-        (CHECK_FLAG_ALL(this->unk_664->flags, ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_NAVI_HAS_INFO) || (this->unk_664->naviEnemyId != 0xFF))) {
+    if ((this->targetActorMaybe != NULL) &&
+        (CHECK_FLAG_ALL(this->targetActorMaybe->flags, ACTOR_FLAG_TARGETABLE | ACTOR_FLAG_NAVI_HAS_INFO) || (this->targetActorMaybe->naviEnemyId != 0xFF))) {
         this->stateFlags2 |= PLAYER_STATE2_NAVI_ALERT;
-    } else if ((this->naviTextId == 0 || CVarGetInteger("gNaviOnL", 0)) && !func_8008E9C4(this) &&
+    } else if ((this->naviTextId == 0 || CVarGetInteger("gNaviOnL", 0)) && !Is_PLAYER_STATE1_ENEMY_TARGET(this) &&
                CHECK_BTN_ALL(sControlInput->press.button, BTN_CUP) && (YREG(15) != 0x10) && (YREG(15) != 0x20) &&
                !func_8083B8F4(this, play)) {
         func_80078884(NA_SE_SY_ERROR);
@@ -5277,6 +5496,7 @@ s32 func_8083B998(Player* this, PlayState* play) {
 }
 
 void func_8083BA90(PlayState* play, Player* this, s32 arg2, f32 xzVelocity, f32 yVelocity) {
+    if (numJumps < 3) {
     func_80837948(play, this, arg2);
     func_80835C58(play, this, func_80844AF4, 0);
 
@@ -5292,6 +5512,7 @@ void func_8083BA90(PlayState* play, Player* this, s32 arg2, f32 xzVelocity, f32
     func_80832854(this);
     func_80832698(this, NA_SE_VO_LI_SWORD_L);
 }
+}
 
 s32 func_8083BB20(Player* this) {
     if (!(this->stateFlags1 & PLAYER_STATE1_SHIELDING) && (Player_GetMeleeWeaponHeld(this) != 0)) {
@@ -5354,7 +5575,7 @@ s32 func_8083BDBC(Player* this, PlayState* play) {
         sp2C = this->unk_84B[this->unk_846];
 
         if (sp2C <= 0) {
-            if (func_80833BCC(this)) {
+            if (Is_AttemptingToTargetOrTargetingEnemy(this)) {
                 if (this->actor.category != ACTORCAT_PLAYER) {
                     if (sp2C < 0) {
                         func_808389E8(this, &gPlayerAnim_link_normal_jump, REG(69) / 100.0f, play);
@@ -5422,7 +5643,7 @@ void func_8083C0B8(Player* this, PlayState* play) {
 }
 
 void func_8083C0E8(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_80840BC8, 1);
+    func_80835C58(play, this, func_80840BC8, 1); //this? lots of stuff, ladders and traps
     func_80832264(play, this, func_80833338(this));
     this->currentYaw = this->actor.shape.rot.y;
 }
@@ -5435,8 +5656,8 @@ void func_8083C148(Player* this, PlayState* play) {
         } else {
             func_80839F90(this, play);
         }
-        if (this->unk_6AD < 4) {
-            this->unk_6AD = 0;
+        if (this->unk_6AD < 4) {     
+                this->unk_6AD = 0;
         }
     }
 
@@ -5465,7 +5686,7 @@ s32 func_8083C2B0(Player* this, PlayState* play) {
 
     if ((play->shootingGalleryStatus == 0) && (this->currentShield != PLAYER_SHIELD_NONE) &&
         CHECK_BTN_ALL(sControlInput->cur.button, BTN_R) &&
-        (Player_IsChildWithHylianShield(this) || (!func_80833B2C(this) && (this->unk_664 == NULL)))) {
+        (Player_IsChildWithHylianShield(this) || (!Is_AttemptingZTarget(this) && (this->targetActorMaybe == NULL)))) {
 
         func_80832318(this);
         func_808323B4(play, this);
@@ -5481,13 +5702,13 @@ s32 func_8083C2B0(Player* this, PlayState* play) {
             }
 
             if (anim != this->skelAnime.animation) {
-                if (func_8008E9C4(this)) {
+                if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                     this->unk_86C = 1.0f;
                 } else {
                     this->unk_86C = 0.0f;
                     func_80833C3C(this);
                 }
-                this->unk_6BC = this->unk_6BE = this->unk_6C0 = 0;
+                this->runningTorsoForwardRotation = this->unk_6BE = this->readyToFireTorsoRotZ = 0;
             }
 
             frame = Animation_GetLastFrame(anim);
@@ -5543,7 +5764,7 @@ s32 func_8083C544(Player* this, PlayState* play) {
     return 0;
 }
 
-s32 func_8083C61C(PlayState* play, Player* this) {
+s32 func_8083C61C(PlayState* play, Player* this) { //use deku nut
     if ((play->roomCtx.curRoom.behaviorType1 != ROOM_BEHAVIOR_TYPE1_2) && (this->actor.bgCheckFlags & 1) &&
         (AMMO(ITEM_NUT) != 0)) {
         func_80835C58(play, this, func_8084E604, 0);
@@ -5555,6 +5776,195 @@ s32 func_8083C61C(PlayState* play, Player* this) {
     return 0;
 }
 
+s32 SSBJump(PlayState* play, Player* this) {
+    if (numJumps == 0)func_80838940(this, gPlayerAnim_link_normal_run_jump, 6.7f, play, NA_SE_VO_LI_AUTO_JUMP); //First Jump
+    else if (numJumps == 1) {
+        func_80838940(this, &gPlayerAnim_link_fighter_backturn_jump, 6.7f, play, NA_SE_VO_LI_AUTO_JUMP); //Double Jump
+        Vec3f splashPos = this->actor.world.pos;
+        splashPos.x += this->actor.velocity.x * 3.0f;
+        splashPos.z += this->actor.velocity.z * 3.0f;
+        splashPos.y -= 0.0f;
+        EffectSsGRipple_Spawn(play, &splashPos, 10, 250, 0);
+        EffectSsGRipple_Spawn(play, &splashPos, 10, 250, 0);
+        EffectSsGRipple_Spawn(play, &splashPos, 10, 250, 0);
+
+    }
+    else if (numJumps == 2) { //Triple Jump
+        if (CUR_EQUIP_VALUE(EQUIP_TYPE_SWORD) != EQUIP_VALUE_SWORD_NONE) { // cant spin jump if no sword equipped
+            this->heldItemAction = PLAYER_IA_SWORD_KOKIRI; //Equip Sword
+            this->heldItemId = ITEM_SWORD_KOKIRI;
+            this->meleeWeaponState = 1; //Sword Does Damage
+            jump3timer = 0;
+
+            func_80838940(this, &gPlayerAnim_link_fighter_Wrolling_kiru, 10.0f, play, NA_SE_VO_LI_SWORD_L);
+        }
+
+    }
+    return 1;
+}
+
+bool OverHeadPrep(PlayState* play, Player* this, s32 item) {
+    s32 nextAnimType;
+    this->nextModelGroup = PLAYER_MODELGROUP_EXPLOSIVES; //Hold a bomb overhead
+    nextAnimType = gPlayerModelTypes[this->nextModelGroup][PLAYER_MODELGROUPENTRY_ANIM];
+
+    if ((this->heldItemAction >= 0) && (item != this->heldItemId)) {
+        this->heldItemId = item;
+        this->stateFlags1 |= PLAYER_STATE1_START_PUTAWAY;
+        //this->stateFlags1 &= ~(PLAYER_STATE1_ITEM_IN_HAND | PLAYER_STATE1_BOOMERANG_IN_HAND);
+        this->heldItemAction = this->itemAction = PLAYER_IA_BOMBCHU;
+        this->modelGroup = this->nextModelGroup;
+
+        return true;
+    }
+    return false;
+}
+
+
+bool ProjectileWeaponPrep(PlayState* play, Player* this, s32 item) {
+    s32 nextAnimType;
+    this->nextModelGroup = PLAYER_MODELGROUP_BOW_SLINGSHOT; //Hold a hookshot in right hand
+    nextAnimType = gPlayerModelTypes[this->nextModelGroup][PLAYER_MODELGROUPENTRY_ANIM];
+
+    if ((this->heldItemAction >= 0) && (item != this->heldItemId)) {
+
+
+        return true;
+    }
+    return false;
+}
+
+void DespawnHeldGlider(PlayState* play, Player* this) {
+    Actor* heldActor = this->heldActor;
+    if (heldActor->id == ACTOR_EN_GLIDER) {
+        heldActor->scale = (Vec3f){ 0.0f,0.0f,0.0f };
+        func_80834644(play, this);
+        glideResetTimer = 5;
+        isGliding = false;
+    }
+}
+
+s32 Glide(PlayState* play, Player* this) {
+    personalUpdraftTimer = 0;
+    if (numJumps == 0)func_80838940(this, gPlayerAnim_link_normal_run_jump, 6.7f, play, NA_SE_VO_LI_AUTO_JUMP); //First Jump
+    else if ((numJumps >= 1) & (glideResetTimer == 0)) {
+        if (OverHeadPrep(play,this, ITEM_GLIDER)) {
+            isGliding = true;
+
+            Actor* spawnedActor;
+
+            spawnedActor = Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_EN_GLIDER,
+                this->actor.world.pos.x, this->actor.world.pos.y, this->actor.world.pos.z, 0,
+                this->actor.shape.rot.y, 0, 0);
+
+            this->interactRangeActor = spawnedActor;
+            this->heldActor = spawnedActor;
+            this->getItemId = GI_NONE;
+            this->getItemEntry = (GetItemEntry)GET_ITEM_NONE;
+            this->unk_3BC.y = spawnedActor->shape.rot.y - this->actor.shape.rot.y;
+            this->stateFlags1 |= PLAYER_STATE1_ITEM_OVER_HEAD;
+            
+            if (landedAfterGliding) {
+                landedAfterGliding = false;
+                this->actor.velocity.y += 8.0f;
+                if (this->actor.velocity.y >= 4.0f) this->actor.velocity.y = 4.0f;
+            }
+            else {
+                this->actor.velocity.y += 4.0f;
+                if (this->actor.velocity.y >= 0.0f) this->actor.velocity.y = 0.0f;
+            }
+        }
+    }
+}
+
+s32 SpawnWindZone(PlayState* play, Player* this) {
+    if ((this->actor.bgCheckFlags & 1) && (this->actor.speedXZ == 0.0f)) { //is on ground and not moving
+        if (personalUpdraftTimer == 0) {
+            func_808322D0(play, this, &gPlayerAnim_link_magic_honoo2);
+        }
+        if (personalUpdraftTimer == 20) {
+            Audio_PlayActorSound2(&this->actor, NA_SE_EV_ICE_MELT);
+            Actor_Spawn(&play->actorCtx, play, ACTOR_WIND_ZONE, this->actor.world.pos.x,
+                this->actor.world.pos.y, this->actor.world.pos.z, 0,
+                this->actor.shape.rot.y, 0, 1, 0); //param 0 makes permanent wind zone 
+            this->actor.gravity = +2.0f;
+            this->actor.velocity.y = 6.7f;
+            numJumps = 1;
+            this->actor.bgCheckFlags &= ~1;
+            this->stateFlags1 |= PLAYER_STATE1_JUMPING;
+            Glide(play, this);
+        }
+        personalUpdraftTimer++;
+    }
+    else personalUpdraftTimer = -1;
+}
+
+
+void SwingItem(Player* this, PlayState* play) {
+    func_8083721C(this);//Stop Moving With Animation
+    if (LinkAnimation_Update(play, &this->skelAnime)) {
+        func_8083C0E8(this, play);
+    }
+}
+
+void SpawnFire(PlayState* play, Player* this) {
+    Actor_Spawn(&play->actorCtx, play, ACTOR_LANTERN_FIRE, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].x,
+        this->bodyPartsPos[PLAYER_BODYPART_R_HAND].y + 20.0f, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].z, 0,
+        this->actor.shape.rot.y, 0, lanternType, 0);
+ /*   Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_LANTERN_FIRE, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].x,
+        this->bodyPartsPos[PLAYER_BODYPART_R_HAND].y + 20.0f, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].z, 0,
+        this->actor.shape.rot.y - 9000, 0, 1);
+    Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_LANTERN_FIRE, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].x,
+        this->bodyPartsPos[PLAYER_BODYPART_R_HAND].y + 20.0f, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].z, 0,
+        this->actor.shape.rot.y - 18000, 0, 2);
+    Actor_SpawnAsChild(&play->actorCtx, &this->actor, play, ACTOR_LANTERN_FIRE, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].x,
+        this->bodyPartsPos[PLAYER_BODYPART_R_HAND].y + 20.0f, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].z, 0,
+        this->actor.shape.rot.y - 27000, 0, 3);
+        */
+}
+void ChangeLantern(PlayState* play, Player* this) {
+    if (actionButtonTimer == 10) {
+        lanternType++;
+        if (lanternType > 3) lanternType = 0;
+        Lantern(play, this);
+        actionButtonTimer = 0;
+       
+    }
+    else actionButtonTimer++;
+}
+
+s32 Lantern(PlayState* play, Player* this) {
+    if (this->heldItemAction != PLAYER_IA_LANTERN) {
+        this->stateFlags1 |= PLAYER_STATE1_START_PUTAWAY;
+        this->heldItemAction = PLAYER_IA_LANTERN;
+
+        func_80835C58(play, this, SwingItem, 0);
+        func_808322D0(play, this, &gPlayerAnim_link_bottle_bug_miss);
+        Player_PlaySfx(&this->actor, NA_SE_IT_SWORD_SWING);
+        func_80832698(this, NA_SE_VO_LI_AUTO_JUMP);
+
+        SpawnFire(play, this);    
+    }
+    else {
+        func_80835C58(play, this, SwingItem, 0);
+        func_808322D0(play, this, &gPlayerAnim_link_bottle_bug_miss);
+        Player_PlaySfx(&this->actor, NA_SE_IT_SWORD_SWING);
+        func_80832698(this, NA_SE_VO_LI_AUTO_JUMP);
+
+        this->heldItemId = ITEM_LANTERN;
+        this->itemAction = PLAYER_IA_LANTERN;
+
+        SpawnFire(play, this);
+    }
+}
+
+s32 Stasis(PlayState* play, Player* this) { //Maybe ULTRAHAND NOW?
+    this->itemAction = PLAYER_IA_STASIS;
+    this->heldItemAction = PLAYER_IA_STASIS;
+    this->heldItemId = ITEM_STASIS;
+    func_80834D2C(this, play);
+}
+
 static struct_80854554 D_80854554[] = {
     { &gPlayerAnim_link_bottle_bug_miss, &gPlayerAnim_link_bottle_bug_in, 2, 3 },
     { &gPlayerAnim_link_bottle_fish_miss, &gPlayerAnim_link_bottle_fish_in, 5, 3 },
@@ -5606,7 +6016,7 @@ s32 func_8083C6B8(PlayState* play, Player* this) {
 void func_8083C858(Player* this, PlayState* play) {
     PlayerFunc674 func;
 
-    if (func_80833BCC(this)) {
+    if (Is_AttemptingToTargetOrTargetingEnemy(this)) {
         func = func_8084227C;
     } else {
         func = func_80842180;
@@ -5685,8 +6095,13 @@ void func_8083CB2C(Player* this, s16 yaw, PlayState* play) {
 }
 
 void func_8083CB94(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_80840DE4, 1);
-    func_80832BE8(play, this, D_80853914[PLAYER_ANIMGROUP_walk][this->modelAnimType]);
+    //CUSTOM - Don't walk sideways if third person aiming bow or hookshot
+    if (!((this->heldItemAction >= PLAYER_IA_BOW) & (this->heldItemAction <= PLAYER_IA_LONGSHOT))){
+        if ((this->heldItemAction != PLAYER_IA_STASIS) & (this->unk_6AD != 0)) {
+            func_80835C58(play, this, func_80840DE4, 1);
+            func_80832BE8(play, this, D_80853914[PLAYER_ANIMGROUP_walk][this->modelAnimType]);
+        }
+    }
 }
 
 void func_8083CBF0(Player* this, s16 yaw, PlayState* play) {
@@ -5698,8 +6113,14 @@ void func_8083CBF0(Player* this, s16 yaw, PlayState* play) {
 }
 
 void func_8083CC9C(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_8084193C, 1);
-    func_80832BE8(play, this, D_80853914[PLAYER_ANIMGROUP_side_walkR][this->modelAnimType]);
+    //CUSTOM - Don't walk sideways if third person aiming bow or hookshot
+    if (!((this->heldItemAction >= PLAYER_IA_BOW) & (this->heldItemAction <= PLAYER_IA_LONGSHOT))) {
+        if ((this->heldItemAction != PLAYER_IA_STASIS) & (this->unk_6AD != 0)) {
+            func_80835C58(play, this, func_8084193C, 1);
+            func_80832BE8(play, this, D_80853914[PLAYER_ANIMGROUP_side_walkR][this->modelAnimType]);
+        }
+    }
+
     this->unk_868 = 0.0f;
 }
 
@@ -5986,7 +6407,7 @@ void func_8083D6EC(PlayState* play, Player* this) {
                 ripplePos.z = (Rand_ZeroOne() * 10.0f) + this->actor.world.pos.z;
                 EffectSsGRipple_Spawn(play, &ripplePos, 100, 500, 0);
 
-                if ((this->linearVelocity > 4.0f) && !func_808332B8(this) &&
+                if ((this->linearVelocity > 4.0f) && !PlayerIsInWaterWithoutIronBootsOn(this) &&
                     ((this->actor.world.pos.y + this->actor.yDistToWater) <
                      this->bodyPartsPos[PLAYER_BODYPART_WAIST].y)) {
                     func_8083CFA8(play, this, 20.0f,
@@ -6015,7 +6436,7 @@ void func_8083D6EC(PlayState* play, Player* this) {
 }
 
 s32 func_8083DB98(Player* this, s32 arg1) {
-    Actor* unk_664 = this->unk_664;
+    Actor* targetActorMaybe = this->targetActorMaybe;
     Vec3f sp30;
     s16 sp2E;
     s16 sp2C;
@@ -6023,11 +6444,11 @@ s32 func_8083DB98(Player* this, s32 arg1) {
     sp30.x = this->actor.world.pos.x;
     sp30.y = this->bodyPartsPos[PLAYER_BODYPART_HEAD].y + 3.0f;
     sp30.z = this->actor.world.pos.z;
-    sp2E = Math_Vec3f_Pitch(&sp30, &unk_664->focus.pos);
-    sp2C = Math_Vec3f_Yaw(&sp30, &unk_664->focus.pos);
+    sp2E = Math_Vec3f_Pitch(&sp30, &targetActorMaybe->focus.pos);
+    sp2C = Math_Vec3f_Yaw(&sp30, &targetActorMaybe->focus.pos);
     Math_SmoothStepToS(&this->actor.focus.rot.y, sp2C, 4, 10000, 0);
     Math_SmoothStepToS(&this->actor.focus.rot.x, sp2E, 4, 10000, 0);
-    this->unk_6AE |= 2;
+    this->unk_6AE |= PLAYER_STATE4_1FIRST_PERSON_AND_MORE;
 
     return func_80836AB8(this, arg1);
 }
@@ -6040,7 +6461,7 @@ void func_8083DC54(Player* this, PlayState* play) {
     f32 temp1;
     Vec3f sp34;
 
-    if (this->unk_664 != NULL) {
+    if (this->targetActorMaybe != NULL) {
         if (func_8002DD78(this) || func_808334B4(this)) {
             func_8083DB98(this, 1);
         } else {
@@ -6074,11 +6495,14 @@ void func_8083DDC8(Player* this, PlayState* play) {
         temp2 = (s16)(this->currentYaw - this->actor.shape.rot.y) * this->linearVelocity * 0.1f;
         temp1 = CLAMP(temp1, -4000, 4000);
         temp2 = CLAMP(-temp2, -4000, 4000);
-        Math_ScaledStepToS(&this->unk_6BC, temp1, 900);
-        this->unk_6B6 = -(f32)this->unk_6BC * 0.5f;
-        Math_ScaledStepToS(&this->unk_6BA, temp2, 300);
-        Math_ScaledStepToS(&this->unk_6C0, temp2, 200);
-        this->unk_6AE |= 0x168;
+        Math_ScaledStepToS(&this->runningTorsoForwardRotation, temp1, 900);
+        this->runningHeadForwardRotation = -(f32)this->runningTorsoForwardRotation * 0.5f;
+        Math_ScaledStepToS(&this->runningHeadLeanRotation, temp2, 300);
+        Math_ScaledStepToS(&this->readyToFireTorsoRotZ, temp2, 200);
+        this->unk_6AE |= PLAYER_STATE4_8READY_TO_FIRE; //NOT NEEDED
+        this->unk_6AE |= PLAYER_STATE4_6;
+        this->unk_6AE |= PLAYER_STATE4_5;
+        this->unk_6AE |= PLAYER_STATE4_3;
     } else {
         func_8083DC54(this, play);
     }
@@ -6089,7 +6513,7 @@ void func_8083DF68(Player* this, f32 arg1, s16 arg2) {
     Math_ScaledStepToS(&this->currentYaw, arg2, REG(27));
 }
 
-void func_8083DFE0(Player* this, f32* arg1, s16* arg2) {
+void func_8083DFE0(Player* this, f32* arg1, s16* arg2) { //Control Link while in air
     s16 yawDiff = this->currentYaw - *arg2;
 
     if (this->meleeWeaponState == 0) {
@@ -6099,7 +6523,8 @@ void func_8083DFE0(Player* this, f32* arg1, s16* arg2) {
         if (giSpeedModifier != 0) {
             if (giSpeedModifier > 0) {
                 maxSpeed *= giSpeedModifier;
-            } else {
+            }
+            else {
                 maxSpeed /= abs(giSpeedModifier);
             }
         }
@@ -6112,13 +6537,16 @@ void func_8083DFE0(Player* this, f32* arg1, s16* arg2) {
             if (CVarGetInteger("gWalkSpeedToggle", 0)) {
                 if (gWalkSpeedToggle1) {
                     maxSpeed *= CVarGetFloat("gWalkModifierOne", 1.0f);
-                } else if (gWalkSpeedToggle2) {
+                }
+                else if (gWalkSpeedToggle2) {
                     maxSpeed *= CVarGetFloat("gWalkModifierTwo", 1.0f);
                 }
-            } else {
+            }
+            else {
                 if (CHECK_BTN_ALL(sControlInput->cur.button, BTN_MODIFIER1)) {
                     maxSpeed *= CVarGetFloat("gWalkModifierOne", 1.0f);
-                } else if (CHECK_BTN_ALL(sControlInput->cur.button, BTN_MODIFIER2)) {
+                }
+                else if (CHECK_BTN_ALL(sControlInput->cur.button, BTN_MODIFIER2)) {
                     maxSpeed *= CVarGetFloat("gWalkModifierTwo", 1.0f);
                 }
             }
@@ -6131,12 +6559,68 @@ void func_8083DFE0(Player* this, f32* arg1, s16* arg2) {
         if (Math_StepToF(&this->linearVelocity, 0.0f, 1.0f)) {
             this->currentYaw = *arg2;
         }
-    } else {
+    }
+    else {
         Math_AsymStepToF(&this->linearVelocity, *arg1, 0.05f, 0.1f);
         Math_ScaledStepToS(&this->currentYaw, *arg2, 200);
     }
 }
 
+void betterfunc_8083DFE0(Player* this, f32* arg1, s16* arg2) { //Control Link while in air
+    s16 yawDiff = this->currentYaw - *arg2;
+    float maxSpeed = R_RUN_SPEED_LIMIT / 100.0f;
+
+        int32_t giSpeedModifier = GameInteractor_RunSpeedModifier();
+        if (giSpeedModifier != 0) {
+            if (giSpeedModifier > 0) {
+                maxSpeed *= giSpeedModifier;
+            } else {
+                maxSpeed /= abs(giSpeedModifier);
+            }
+        }
+
+        if (CVarGetInteger("gMMBunnyHood", BUNNY_HOOD_VANILLA) == BUNNY_HOOD_FAST_AND_JUMP && this->currentMask == PLAYER_MASK_BUNNY) {
+            maxSpeed *= 1.5f;
+        } 
+        
+        if (CVarGetInteger("gEnableWalkModify", 0) && !CVarGetInteger("gWalkModifierDoesntChangeJump", 0)) {
+            if (CVarGetInteger("gWalkSpeedToggle", 0)) {
+                if (gWalkSpeedToggle1) {
+                    maxSpeed *= CVarGetFloat("gWalkModifierOne", 1.0f);
+                } else if (gWalkSpeedToggle2) {
+                    maxSpeed *= CVarGetFloat("gWalkModifierTwo", 1.0f);
+                }
+            } else {
+                if (CHECK_BTN_ALL(sControlInput->cur.button, BTN_MODIFIER1)) {
+                    maxSpeed *= CVarGetFloat("gWalkModifierOne", 1.0f);
+                } else if (CHECK_BTN_ALL(sControlInput->cur.button, BTN_MODIFIER2)) {
+                    maxSpeed *= CVarGetFloat("gWalkModifierTwo", 1.0f);
+                }
+            }
+        
+        this->linearVelocity = CLAMP(this->linearVelocity, -maxSpeed, maxSpeed);
+    }
+    //current vector
+    float curX = this->linearVelocity * Math_CosS(this->currentYaw);
+    float curY = this->linearVelocity * Math_SinS(this->currentYaw);
+    //target vector
+    float clampedArg1 = CLAMP(*arg1, -maxSpeed, maxSpeed);
+    float newX = clampedArg1 * Math_CosS(*arg2);
+    float newY = clampedArg1 * Math_SinS(*arg2);
+
+    float weight = 0.1f;
+    newX = curX * (1.0f - weight) + newX * weight;
+    newY = curY * (1.0f - weight) + newY * weight;
+
+    float newAngle = Math_Atan2S(newX, newY);
+    float newMag = sqrtf(newX * newX + newY * newY);
+
+    this->linearVelocity = newMag;
+    this->currentYaw = newAngle;
+
+    if (newMag > 0.01f) this->actor.shape.rot.y = this->actor.world.rot.y = this->currentYaw;
+}
+
 static struct_80854578 D_80854578[] = {
     { &gPlayerAnim_link_uma_left_up, 35.17f, 6.6099997f },
     { &gPlayerAnim_link_uma_right_up, -34.16f, 7.91f },
@@ -6492,7 +6976,8 @@ s32 func_8083EB44(Player* this, PlayState* play) {
             if (!func_8083EAF0(this, this->heldActor)) {
                 func_80835C58(play, this, func_808464B0, 1);
                 func_80832264(play, this, D_80853914[PLAYER_ANIMGROUP_put][this->modelAnimType]);
-            } else {
+                }
+                else {
                 func_8083EA94(this, play);
             }
         }
@@ -6769,7 +7254,7 @@ s32 func_8083F570(Player* this, PlayState* play) {
 
 void func_8083F72C(Player* this, LinkAnimationHeader* anim, PlayState* play) {
     if (!func_80836898(play, this, func_8083A388)) {
-        func_80835C58(play, this, func_8084B78C, 0);
+        func_80835C58(play, this, func_8084B78C, 0); //this? push pull stuff
     }
 
     func_80832264(play, this, anim);
@@ -6788,7 +7273,7 @@ s32 func_8083F7BC(Player* this, PlayState* play) {
             return 1;
         }
 
-        if (!func_808332B8(this) && ((this->linearVelocity == 0.0f) || !(this->stateFlags2 & PLAYER_STATE2_DO_ACTION_CLIMB)) &&
+        if (!PlayerIsInWaterWithoutIronBootsOn(this) && ((this->linearVelocity == 0.0f) || !(this->stateFlags2 & PLAYER_STATE2_DO_ACTION_CLIMB)) &&
             (D_808535F0 & 0x40) && (this->actor.bgCheckFlags & 1) && (this->wallHeight >= 39.0f)) {
 
             this->stateFlags2 |= PLAYER_STATE2_DO_ACTION_GRAB;
@@ -6887,7 +7372,7 @@ s32 func_8083FC68(Player* this, f32 arg1, s16 arg2) {
     f32 sp1C = (s16)(arg2 - this->actor.shape.rot.y);
     f32 temp;
 
-    if (this->unk_664 != NULL) {
+    if (this->targetActorMaybe != NULL) {
         func_8083DB98(this, func_8002DD78(this) || func_808334B4(this));
     }
 
@@ -6902,11 +7387,13 @@ s32 func_8083FC68(Player* this, f32 arg1, s16 arg2) {
     return 0;
 }
 
+//Third Perons Rotate
 s32 func_8083FD78(Player* this, f32* arg1, s16* arg2, PlayState* play) {
     s16 sp2E = *arg2 - this->targetYaw;
     u16 sp2C = ABS(sp2E);
 
-    if ((func_8002DD78(this) || func_808334B4(this)) && (this->unk_664 == NULL)) {
+
+    if ((func_8002DD78(this) || func_808334B4(this)) && (this->targetActorMaybe == NULL)) {
         *arg1 *= Math_SinS(sp2C);
 
         if (*arg1 != 0.0f) {
@@ -6915,14 +7402,23 @@ s32 func_8083FD78(Player* this, f32* arg1, s16* arg2, PlayState* play) {
             *arg2 = this->actor.shape.rot.y;
         }
 
-        if (this->unk_664 != NULL) {
+        if (this->targetActorMaybe != NULL) {
             func_8083DB98(this, 1);
         } else {
-            Math_SmoothStepToS(&this->actor.focus.rot.x, sControlInput->rel.stick_y * 240.0f, 14, 4000, 30);
+            //Third Person Rot X
+            //Math_SmoothStepToS(&this->actor.focus.rot.x, sControlInput->rel.stick_y * 240.0f, 14, 4000, 30);
+            //Math_SmoothStepToS(&this->actor.focus.rot.y, sControlInput->rel.stick_x * 240.0f, 14, 4000, 30);
+            this->actor.focus.rot.x -= sControlInput->rel.stick_y * 8.0f;
+            if (this->actor.focus.rot.x > 12000) this->actor.focus.rot.x = 12000;
+            if (this->actor.focus.rot.x < -12000) this->actor.focus.rot.x = -12000;
+            this->targetYaw -= sControlInput->rel.stick_x * 8.0f;
+            //this->actor.world.rot.y = this->targetYaw;
+            //this->actor.shape.rot.y = this->targetYaw;
+
             func_80836AB8(this, 1);
         }
     } else {
-        if (this->unk_664 != NULL) {
+        if (this->targetActorMaybe != NULL) {
             return func_8083FC68(this, *arg1, *arg2);
         } else {
             func_8083DC54(this, play);
@@ -7069,11 +7565,12 @@ void func_80840450(Player* this, PlayState* play) {
     func_8083721C(this);
 
     if (!func_80837348(play, this, D_808543E0, 1)) {
-        if (!func_80833B54(this) && (!func_80833B2C(this) || (func_80834B5C != this->func_82C))) {
+        if (!func_80833B54(this) && (!Is_AttemptingZTarget(this) || (func_80834B5C != this->func_82C))) {
             func_8083CF10(this, play);
             return;
         }
 
+
         func_80837268(this, &sp44, &sp42, 0.0f, play);
 
         temp1 = func_8083FC68(this, sp44, sp42);
@@ -7140,7 +7637,7 @@ void func_808407CC(Player* this, PlayState* play) {
             return;
         }
 
-        if (!func_80833B2C(this)) {
+        if (!Is_AttemptingZTarget(this)) {
             func_80835DAC(play, this, func_80840BC8, 1);
             this->currentYaw = this->actor.shape.rot.y;
             return;
@@ -7191,7 +7688,7 @@ void func_808409CC(PlayState* play, Player* this) {
     s32 sp38;
     s32 sp34;
 
-    if ((this->unk_664 != NULL) ||
+    if ((this->targetActorMaybe != NULL) ||
         (!(heathIsCritical = HealthMeter_IsCritical()) && ((this->unk_6AC = (this->unk_6AC + 1) & 1) != 0))) {
         this->stateFlags2 &= ~PLAYER_STATE2_IDLING;
         anim = func_80833338(this);
@@ -7267,7 +7764,7 @@ void func_80840BC8(Player* this, PlayState* play) {
                 return;
             }
 
-            if (func_80833B2C(this)) {
+            if (Is_AttemptingZTarget(this)) {
                 func_80839F30(this, play);
                 return;
             }
@@ -7340,7 +7837,7 @@ void func_80840DE4(Player* this, PlayState* play) {
             return;
         }
 
-        if (!func_80833B2C(this)) {
+        if (!Is_AttemptingZTarget(this)) {
             func_80853080(this, play);
             return;
         }
@@ -7559,7 +8056,7 @@ void func_8084193C(Player* this, PlayState* play) {
 
         func_80837268(this, &sp3C, &sp3A, 0.0f, play);
 
-        if (func_80833B2C(this)) {
+        if (Is_AttemptingZTarget(this)) {
             temp1 = func_8083FD78(this, &sp3C, &sp3A, play);
         } else {
             temp1 = func_8083FC68(this, sp3C, sp3A);
@@ -7571,7 +8068,7 @@ void func_8084193C(Player* this, PlayState* play) {
         }
 
         if (temp1 < 0) {
-            if (func_80833B2C(this)) {
+            if (Is_AttemptingZTarget(this)) {
                 func_8083CB2C(this, sp3A, play);
             } else {
                 func_8083CBF0(this, sp3A, play);
@@ -7580,7 +8077,7 @@ void func_8084193C(Player* this, PlayState* play) {
         }
 
         if ((this->linearVelocity < 3.6f) && (sp3C < 4.0f)) {
-            if (!func_8008E9C4(this) && func_80833B2C(this)) {
+            if (!Is_PLAYER_STATE1_ENEMY_TARGET(this) && Is_AttemptingZTarget(this)) {
                 func_8083CB94(this, play);
             } else {
                 func_80839F90(this, play);
@@ -7601,8 +8098,10 @@ void func_8084193C(Player* this, PlayState* play) {
         }
 
         sp3C *= 0.9f;
-        Math_AsymStepToF(&this->linearVelocity, sp3C, 2.0f, 3.0f);
-        Math_ScaledStepToS(&this->currentYaw, sp3A, temp3 * 0.1f);
+
+            Math_AsymStepToF(&this->linearVelocity, sp3C, 2.0f, 3.0f);
+            Math_ScaledStepToS(&this->currentYaw, sp3A, temp3 * 0.1f);
+
     }
 }
 
@@ -7738,6 +8237,7 @@ void func_80842180(Player* this, PlayState* play) {
     this->stateFlags2 |= PLAYER_STATE2_DISABLE_ROTATION_Z_TARGET;
     func_80841EE4(this, play);
 
+
     if (!func_80837348(play, this, D_80854424, 1)) {
         if (func_80833C04(this)) {
             func_8083C858(this, play);
@@ -7776,11 +8276,12 @@ void func_80842180(Player* this, PlayState* play) {
                 }
             }
 
-            func_8083DF68(this, sp2C, sp2A);
-            func_8083DDC8(this, play);
+                func_8083DF68(this, sp2C, sp2A); //Walk or Run without Z target
+                func_8083DDC8(this, play);
+
+                if ((this->linearVelocity == 0.0f) && (sp2C == 0.0f)) {
+                    func_8083C0B8(this, play);
 
-            if ((this->linearVelocity == 0.0f) && (sp2C == 0.0f)) {
-                func_8083C0B8(this, play);
             }
         }
     }
@@ -7802,8 +8303,8 @@ void func_8084227C(Player* this, PlayState* play) {
         func_80837268(this, &sp2C, &sp2A, 0.0f, play);
 
         if (!func_8083C484(this, &sp2C, &sp2A)) {
-            if ((func_80833B2C(this) && (sp2C != 0.0f) && (func_8083FD78(this, &sp2C, &sp2A, play) <= 0)) ||
-                (!func_80833B2C(this) && (func_8083FC68(this, sp2C, sp2A) <= 0))) {
+            if ((Is_AttemptingZTarget(this) && (sp2C != 0.0f) && (func_8083FD78(this, &sp2C, &sp2A, play) <= 0)) ||
+                (!Is_AttemptingZTarget(this) && (func_8083FC68(this, sp2C, sp2A) <= 0))) {
                 func_80839F90(this, play);
                 return;
             }
@@ -8034,7 +8535,7 @@ void func_80842D20(PlayState* play, Player* this) {
         func_80832440(play, this);
         func_80835C58(play, this, func_808505DC, 0);
 
-        if (func_8008E9C4(this)) {
+        if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
             sp28 = 2;
         } else {
             sp28 = 0;
@@ -8189,7 +8690,7 @@ void func_80843188(Player* this, PlayState* play) {
         }
 
         Math_ScaledStepToS(&this->actor.focus.rot.x, sp4C, sp48);
-        this->unk_6BC = this->actor.focus.rot.x;
+        this->runningTorsoForwardRotation = this->actor.focus.rot.x;
         Math_ScaledStepToS(&this->unk_6BE, sp4A, sp46);
 
         if (this->unk_84F != 0) {
@@ -8232,7 +8733,9 @@ void func_80843188(Player* this, PlayState* play) {
     this->stateFlags1 |= PLAYER_STATE1_SHIELDING;
     Player_SetModelsForHoldingShield(this);
 
-    this->unk_6AE |= 0xC1;
+    this->unk_6AE |= PLAYER_STATE4_7;
+    this->unk_6AE |= PLAYER_STATE4_6;
+    this->unk_6AE |= PLAYER_STATE4_0;
 }
 
 void func_808435C4(Player* this, PlayState* play) {
@@ -8517,7 +9020,7 @@ s32 func_80843E64(PlayState* play, Player* this) {
     return 0;
 }
 
-void func_8084409C(PlayState* play, Player* this, f32 speedXZ, f32 velocityY) {
+void func_8084409C(PlayState* play, Player* this, f32 speedXZ, f32 velocityY) { //Drop? or Throw? held actor
     Actor* heldActor = this->heldActor;
 
     if (!func_80835644(play, this, heldActor)) {
@@ -8536,7 +9039,7 @@ void func_8084411C(Player* this, PlayState* play) {
 
     if (gSaveContext.respawn[RESPAWN_MODE_TOP].data > 40) {
         this->actor.gravity = 0.0f;
-    } else if (func_8008E9C4(this)) {
+    } else if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
         this->actor.gravity = -1.2f;
     }
 
@@ -8554,12 +9057,20 @@ void func_8084411C(Player* this, PlayState* play) {
                 CHECK_BTN_ANY(sControlInput->press.button, buttonsToCheck)) {
                 func_8084409C(play, this, this->linearVelocity + 2.0f, this->actor.velocity.y + 2.0f);
             }
+            if (!func_80835644(play, this, heldActor) && (heldActor->id == ACTOR_EN_GLIDER) &&
+                CHECK_BTN_ANY(sControlInput->press.button, buttonsToCheck)) {
+                DespawnHeldGlider(play, this);
+            }
         }
 
         LinkAnimation_Update(play, &this->skelAnime);
 
         if (!(this->stateFlags2 & PLAYER_STATE2_HOPPING)) {
-            func_8083DFE0(this, &sp4C, &sp4A);
+            if (this->stateFlags1 & PLAYER_STATE1_ITEM_OVER_HEAD) {
+                if (this->heldActor->id == ACTOR_EN_GLIDER) betterfunc_8083DFE0(this, &sp4C, &sp4A); //Control Link while in air
+                else func_8083DFE0(this, &sp4C, &sp4A);
+            }
+            else func_8083DFE0(this, &sp4C, &sp4A);           
         }
 
         func_80836670(this, play);
@@ -8612,14 +9123,14 @@ void func_8084411C(Player* this, PlayState* play) {
         s32 sp3C;
 
         if (this->stateFlags2 & PLAYER_STATE2_HOPPING) {
-            if (func_8008E9C4(this)) {
+            if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                 anim = D_80853D4C[this->unk_84F][2];
             } else {
                 anim = D_80853D4C[this->unk_84F][1];
             }
         } else if (this->skelAnime.animation == &gPlayerAnim_link_normal_run_jump) {
             anim = &gPlayerAnim_link_normal_run_jump_end;
-        } else if (func_8008E9C4(this)) {
+        } else if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
             anim = &gPlayerAnim_link_anchor_landingR;
             func_80833C3C(this);
         } else if (this->fallDistance <= 80) {
@@ -8807,11 +9318,11 @@ s32 func_80844BE4(Player* this, PlayState* play) {
 }
 
 void func_80844CF8(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_80845000, 1);
+    func_80835C58(play, this, func_80845000, 1); //this? spin attack
 }
 
 void func_80844D30(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_80845308, 1);
+    func_80835C58(play, this, func_80845308, 1); //this? spin attack
 }
 
 void func_80844D68(Player* this, PlayState* play) {
@@ -9193,6 +9704,7 @@ void func_80845CA4(Player* this, PlayState* play) {
                 sp34 = gSaveContext.entranceSpeed;
 
                 if (D_808535F4 != 0) {
+                    //angle to walk while going through doorway
                     this->unk_450.x = (Math_SinS(D_808535FC) * 400.0f) + this->actor.world.pos.x;
                     this->unk_450.z = (Math_CosS(D_808535FC) * 400.0f) + this->actor.world.pos.z;
                 }
@@ -9508,22 +10020,9 @@ void func_80846660(PlayState* play, Player* this) {
 
 static u8 D_808546F0[] = { ITEM_SWORD_MASTER, ITEM_SWORD_KOKIRI };
 
+//Choose which hookshot based on Link's age
 void func_80846720(PlayState* play, Player* this, s32 arg2) {
-    s32 item = D_808546F0[(void)0, gSaveContext.linkAge];
-    s32 actionParam = sItemActionParams[item];
-
-    func_80835EFC(this);
-    func_808323B4(play, this);
 
-    this->heldItemId = item;
-    this->nextModelGroup = Player_ActionToModelGroup(this, actionParam);
-
-    func_8083399C(play, this, actionParam);
-    func_80834644(play, this);
-
-    if (arg2 != 0) {
-        Player_PlaySfx(&this->actor, NA_SE_IT_SWORD_PICKOUT);
-    }
 }
 
 static Vec3f D_808546F4 = { -1.0f, 69.0f, 20.0f };
@@ -9755,7 +10254,7 @@ void Player_Init(Actor* thisx, PlayState* play2) {
     MREG(64) = 0;
 }
 
-void func_808471F4(s16* pValue) {
+void StepToZero(s16* pValue) {
     s16 step;
 
     step = (ABS(*pValue) * 100.0f) / 1000.0f;
@@ -9766,50 +10265,50 @@ void func_808471F4(s16* pValue) {
 
 void func_80847298(Player* this) {
     s16 sp26;
-
-    if (!(this->unk_6AE & 2)) {
+    //Whichever Flags are set are skipped over while Stepping toward Zero
+    if (!(this->unk_6AE & PLAYER_STATE4_1FIRST_PERSON_AND_MORE)) {
         sp26 = this->actor.focus.rot.y - this->actor.shape.rot.y;
-        func_808471F4(&sp26);
+        StepToZero(&sp26);
         this->actor.focus.rot.y = this->actor.shape.rot.y + sp26;
     }
 
-    if (!(this->unk_6AE & 1)) {
-        func_808471F4(&this->actor.focus.rot.x);
+    if (!(this->unk_6AE & PLAYER_STATE4_0)) {
+        StepToZero(&this->actor.focus.rot.x);
     }
 
-    if (!(this->unk_6AE & 8)) {
-        func_808471F4(&this->unk_6B6);
+    if (!(this->unk_6AE & PLAYER_STATE4_3)) {
+        StepToZero(&this->runningHeadForwardRotation); //rot.z related
     }
 
-    if (!(this->unk_6AE & 0x40)) {
-        func_808471F4(&this->unk_6BC);
+    if (!(this->unk_6AE & PLAYER_STATE4_6)) {
+        StepToZero(&this->runningTorsoForwardRotation);
     }
 
-    if (!(this->unk_6AE & 4)) {
-        func_808471F4(&this->actor.focus.rot.z);
+    if (!(this->unk_6AE & PLAYER_STATE4_2)) {
+        StepToZero(&this->actor.focus.rot.z);
     }
 
-    if (!(this->unk_6AE & 0x10)) {
-        func_808471F4(&this->unk_6B8);
+    if (!(this->unk_6AE & PLAYER_STATE4_4FOCUS_HEAD_ROTATION_Y)) {
+        StepToZero(&this->focusHeadYRotation);
     }
 
-    if (!(this->unk_6AE & 0x20)) {
-        func_808471F4(&this->unk_6BA);
+    if (!(this->unk_6AE & PLAYER_STATE4_5)) {
+        StepToZero(&this->runningHeadLeanRotation); //rot.x related
     }
 
-    if (!(this->unk_6AE & 0x80)) {
+    if (!(this->unk_6AE & PLAYER_STATE4_7)) {
         if (this->unk_6B0 != 0) {
-            func_808471F4(&this->unk_6B0);
+            StepToZero(&this->unk_6B0);
         } else {
-            func_808471F4(&this->unk_6BE);
+            StepToZero(&this->unk_6BE); //shape.rot.y related
         }
     }
 
-    if (!(this->unk_6AE & 0x100)) {
-        func_808471F4(&this->unk_6C0);
+    if (!(this->unk_6AE & PLAYER_STATE4_8READY_TO_FIRE)) {
+        StepToZero(&this->readyToFireTorsoRotZ);
     }
 
-    this->unk_6AE = 0;
+    this->unk_6AE = 0;//Clear all Flags
 }
 
 static f32 D_80854784[] = { 120.0f, 240.0f, 360.0f };
@@ -9817,13 +10316,13 @@ static f32 D_80854784[] = { 120.0f, 240.0f, 360.0f };
 static u8 sDiveDoActions[] = { DO_ACTION_1, DO_ACTION_2, DO_ACTION_3, DO_ACTION_4,
                                DO_ACTION_5, DO_ACTION_6, DO_ACTION_7, DO_ACTION_8 };
 
-void func_808473D4(PlayState* play, Player* this) {
+void UpdateAButtonAction(PlayState* play, Player* this) {
     if ((Message_GetState(&play->msgCtx) == TEXT_STATE_NONE) && (this->actor.category == ACTORCAT_PLAYER)) {
         Actor* heldActor = this->heldActor;
         Actor* interactRangeActor = this->interactRangeActor;
         s32 sp24;
         s32 sp20 = this->unk_84B[this->unk_846];
-        s32 sp1C = func_808332B8(this);
+        s32 sp1C = PlayerIsInWaterWithoutIronBootsOn(this);
         s32 doAction = DO_ACTION_NONE;
 
         if (!Player_InBlockingCsMode(play, this)) {
@@ -9894,16 +10393,16 @@ void func_808473D4(PlayState* play, Player* this) {
                     doAction = sDiveDoActions[sp24];
                 } else if (sp1C && !(this->stateFlags2 & PLAYER_STATE2_UNDERWATER)) {
                     doAction = DO_ACTION_DIVE;
-                } else if (!sp1C && (!(this->stateFlags1 & PLAYER_STATE1_SHIELDING) || func_80833BCC(this) ||
+                } else if (!sp1C && (!(this->stateFlags1 & PLAYER_STATE1_SHIELDING) || Is_AttemptingToTargetOrTargetingEnemy(this) ||
                                      !Player_IsChildWithHylianShield(this))) {
                     if ((!(this->stateFlags1 & PLAYER_STATE1_CLIMBING_LEDGE) && (sp20 <= 0) &&
-                         (func_8008E9C4(this) ||
-                          ((D_808535E4 != 7) && (func_80833B2C(this) ||
+                         (Is_PLAYER_STATE1_ENEMY_TARGET(this) ||
+                          ((D_808535E4 != 7) && (Is_AttemptingZTarget(this) ||
                                                  ((play->roomCtx.curRoom.behaviorType1 != ROOM_BEHAVIOR_TYPE1_2) &&
                                                   !(this->stateFlags1 & PLAYER_STATE1_SHIELDING) && (sp20 == 0))))))) {
                         doAction = DO_ACTION_ATTACK;
                     } else if ((play->roomCtx.curRoom.behaviorType1 != ROOM_BEHAVIOR_TYPE1_2) &&
-                               func_80833BCC(this) && (sp20 > 0)) {
+                               Is_AttemptingToTargetOrTargetingEnemy(this) && (sp20 > 0)) {
                         doAction = DO_ACTION_JUMP;
                     } else if ((this->heldItemAction >= PLAYER_IA_SWORD_MASTER) ||
                                ((this->stateFlags2 & PLAYER_STATE2_NAVI_OUT) &&
@@ -9928,7 +10427,7 @@ void func_808473D4(PlayState* play, Player* this) {
         Interface_SetDoAction(play, doAction);
 
         if (this->stateFlags2 & PLAYER_STATE2_NAVI_ALERT) {
-            if (this->unk_664 != NULL) {
+            if (this->targetActorMaybe != NULL) {
                 Interface_SetNaviCall(play, 0x1E);
             } else {
                 Interface_SetNaviCall(play, 0x1D);
@@ -10101,8 +10600,7 @@ void func_80847BA0(PlayState* play, Player* this) {
 
         D_808535F0 = func_80041DB8(&play->colCtx, this->actor.wallPoly, this->actor.wallBgId);
 
-        // conflicts arise from these two being enabled at once, and with ClimbEverything on, FixVineFall is redundant anyway
-        if (CVarGetInteger("gFixVineFall", 0) && !CVarGetInteger("gClimbEverything", 0)) {
+        if (CVarGetInteger("gFixVineFall", 0)) {
             /* This fixes the "started climbing a wall and then immediately fell off" bug.
             * The main idea is if a climbing wall is detected, double-check that it will
             * still be valid once climbing begins by doing a second raycast with a small
@@ -10288,7 +10786,7 @@ void func_80847BA0(PlayState* play, Player* this) {
 void Player_UpdateCamAndSeqModes(PlayState* play, Player* this) {
     u8 seqMode;
     s32 pad;
-    Actor* unk_664;
+    Actor* targetActorMaybe;
     s32 camMode;
 
     if (this->actor.category == ACTORCAT_PLAYER) {
@@ -10304,7 +10802,7 @@ void Player_UpdateCamAndSeqModes(PlayState* play, Player* this) {
                 camMode = CAM_MODE_STILL;
             } else if (this->stateFlags2 & PLAYER_STATE2_GRABBING_DYNAPOLY) {
                 camMode = CAM_MODE_PUSHPULL;
-            } else if ((unk_664 = this->unk_664) != NULL) {
+            } else if ((targetActorMaybe = this->targetActorMaybe) != NULL) {
                 if (CHECK_FLAG_ALL(this->actor.flags, ACTOR_FLAG_PLAYER_TALKED_TO)) {
                     camMode = CAM_MODE_TALK;
                 } else if (this->stateFlags1 & PLAYER_STATE1_TARGET_LOCKED) {
@@ -10316,27 +10814,31 @@ void Player_UpdateCamAndSeqModes(PlayState* play, Player* this) {
                 } else {
                     camMode = CAM_MODE_BATTLE;
                 }
-                Camera_SetParam(Play_GetCamera(play, 0), 8, unk_664);
+                Camera_SetParam(Play_GetCamera(play, 0), 8, targetActorMaybe);
             } else if (this->stateFlags1 & PLAYER_STATE1_CHARGING_SPIN_ATTACK) {
                 camMode = CAM_MODE_CHARGE;
             } else if (this->stateFlags1 & PLAYER_STATE1_THREW_BOOMERANG) {
                 camMode = CAM_MODE_FOLLOWBOOMERANG;
                 Camera_SetParam(Play_GetCamera(play, 0), 8, this->boomerangActor);
             } else if (this->stateFlags1 & (PLAYER_STATE1_HANGING_OFF_LEDGE | PLAYER_STATE1_CLIMBING_LEDGE)) {
-                if (func_80833B2C(this)) {
+                if (Is_AttemptingZTarget(this)) {
                     camMode = CAM_MODE_HANGZ;
                 } else {
                     camMode = CAM_MODE_HANG;
                 }
-            } else if (this->stateFlags1 & (PLAYER_STATE1_TARGET_NOTHING | PLAYER_STATE1_30)) {
+            }
+            else if (this->stateFlags1 & (PLAYER_STATE1_TARGET_NOTHING | PLAYER_STATE1_30)) {
                 if (func_8002DD78(this) || func_808334B4(this)) {
                     camMode = CAM_MODE_BOWARROWZ;
-                } else if (this->stateFlags1 & PLAYER_STATE1_CLIMBING_LADDER) {
+                }
+                else if (this->stateFlags1 & PLAYER_STATE1_CLIMBING_LADDER) {
                     camMode = CAM_MODE_CLIMBZ;
-                } else {
+                }
+                else {
                     camMode = CAM_MODE_TARGET;
                 }
-            } else if (this->stateFlags1 & (PLAYER_STATE1_JUMPING | PLAYER_STATE1_CLIMBING_LADDER)) {
+            }
+             else if (this->stateFlags1 & (PLAYER_STATE1_JUMPING | PLAYER_STATE1_CLIMBING_LADDER)) {
                 if ((func_80845668 == this->func_674) || (this->stateFlags1 & PLAYER_STATE1_CLIMBING_LADDER)) {
                     camMode = CAM_MODE_CLIMB;
                 } else {
@@ -10390,7 +10892,7 @@ void func_80848A04(PlayState* play, Player* this) {
     }
 
     if (this->unk_85C == 0.0f && CVarGetInteger("gDekuStickCheat", DEKU_STICK_NORMAL) == DEKU_STICK_NORMAL) {
-        func_80835F44(play, this, 0xFF);
+        func_80835F44(play, this, 0xFF); 
         return;
     }
 
@@ -10667,7 +11169,43 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
     s32 pad;
 
     sControlInput = input;
+    if (glideResetTimer > 0) glideResetTimer--;
+    if (this->actor.bgCheckFlags & 1) {  //When standing on ground - Reset numJumps, Turn off sword attack
+        if (numJumps != 0) this->meleeWeaponState = 0;
+        numJumps = 0;
+        landedAfterGliding = true;
+        if (isGliding) {
+            if (this->stateFlags1 & PLAYER_STATE1_ITEM_OVER_HEAD) {
+                DespawnHeldGlider(play, this);
+            }
+            isGliding = false;
+            glideResetTimer = 0;
+        }
+    }
+
+    if (this->stateFlags1 & PLAYER_STATE1_CLIMBING_LADDER) {  //1_21 //When climbing somthing - set to already jumped once
+        this->meleeWeaponState = 0;
+        numJumps = 1;
+    }
 
+    if (this->stateFlags2 & PLAYER_STATE2_DISABLE_ROTATION_ALWAYS) { //2_6 //When hanging from a ledge- set to already jumped once
+        this->meleeWeaponState = 0;
+        numJumps = 1;
+    }
+    if (this->stateFlags1 & PLAYER_STATE1_IN_WATER) {
+        this->meleeWeaponState = 0;
+        numJumps = 1;
+    }
+    if (numJumps == 3) {
+        if (jump3timer >= 13) {//once jump 3 attack is done - turn off sword, start flickering link
+            this->meleeWeaponState = 0;
+            if (((jump3timer - 13) % 2) == 0) { //every other frame set filter to black
+                Actor_SetColorFilter(&this->actor, 0x8000, 0, 0, 1);
+            }
+        }
+        jump3timer++;
+    }
+    //TIMERS
     if (this->unk_A86 < 0) {
         this->unk_A86++;
         if (this->unk_A86 == 0) {
@@ -10700,11 +11238,11 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
         this->unk_890--;
     }
 
-    func_808473D4(play, this);
-    func_80836BEC(this, play);
+    UpdateAButtonAction(play, this);
+    UpdateZButtonHeldOrAlreadyLockedOn(this, play);
 
     if ((this->heldItemAction == PLAYER_IA_DEKU_STICK) && ((this->unk_860 != 0) || CVarGetInteger("gDekuStickCheat", DEKU_STICK_NORMAL) == DEKU_STICK_UNBREAKABLE_AND_ALWAYS_ON_FIRE)) {
-        func_80848A04(play, this);
+        func_80848A04(play, this); //See if Deku Stick is Burnt out to Unequip?
     } else if ((this->heldItemAction == PLAYER_IA_FISHING_POLE) && (this->unk_860 < 0)) {
         this->unk_860++;
     }
@@ -10729,7 +11267,7 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
             Actor_MoveForward(&this->actor);
         }
 
-        func_80847BA0(play, this);
+        func_80847BA0(play, this); //crawling stuff, see if a seamless load need to happen?
     } else {
         f32 temp_f0;
         f32 phi_f12;
@@ -10737,16 +11275,16 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
         if (this->currentBoots != this->prevBoots) {
             if (this->currentBoots == PLAYER_BOOTS_IRON) {
                 if (this->stateFlags1 & PLAYER_STATE1_IN_WATER) {
-                    func_80832340(play, this);
+                    func_80832340(play, this); //Dive Camera Stuff?
                     if (this->ageProperties->unk_2C < this->actor.yDistToWater) {
-                        this->stateFlags2 |= PLAYER_STATE2_UNDERWATER;
+                        this->stateFlags2 |= PLAYER_STATE2_UNDERWATER; //Adult Link is taller, can stand in deeper water
                     }
                 }
             } else {
                 if (this->stateFlags1 & PLAYER_STATE1_IN_WATER) {
                     if ((this->prevBoots == PLAYER_BOOTS_IRON) || (this->actor.bgCheckFlags & 1)) {
                         func_8083D36C(play, this);
-                        this->stateFlags2 &= ~PLAYER_STATE2_UNDERWATER;
+                        this->stateFlags2 &= ~PLAYER_STATE2_UNDERWATER; 
                     }
                 }
             }
@@ -10772,7 +11310,7 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
         }
 
         Math_ScaledStepToS(&this->unk_6C2, 0, 400);
-        func_80032CB4(this->unk_3A8, 20, 80, 6);
+        func_80032CB4(this->unk_3A8, 20, 80, 6); //Random Number for Timing Face Animations
 
         this->actor.shape.face = this->unk_3A8[0] + ((play->gameplayFrames & 32) ? 0 : 3);
 
@@ -10780,7 +11318,7 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
             Player_UpdateBunnyEars(this);
         }
 
-        if (func_8002DD6C(this) != 0) {
+        if (PlayerStateItemInHand(this) == true) {
             func_8084FF7C(this);
         }
 
@@ -10810,13 +11348,13 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
 
                     Math_ScaledStepToS(&this->actor.world.rot.y, sp6E, phi_v0);
                 }
-
                 if ((this->linearVelocity == 0.0f) && (this->actor.speedXZ != 0.0f)) {
                     func_800F4138(&this->actor.projectedPos, 0xD0, this->actor.speedXZ);
                 }
             } else {
-                this->actor.speedXZ = this->linearVelocity;
-                this->actor.world.rot.y = this->currentYaw;
+
+                   this->actor.speedXZ = this->linearVelocity;
+                    this->actor.world.rot.y = this->currentYaw;
             }
 
             func_8002D868(&this->actor);
@@ -10828,8 +11366,9 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
                 this->actor.velocity.z += this->windSpeed * Math_CosS(this->windDirection);
             }
 
-            func_8002D7EC(&this->actor);
-            func_80847BA0(play, this);
+                func_8002D7EC(&this->actor); //apply actor velocities
+                func_80847BA0(play, this);
+
         } else {
             D_808535E4 = 0;
             this->unk_A7A = 0;
@@ -10883,8 +11422,8 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
             Math_StepToF(&this->windSpeed, 0.0f, (this->stateFlags1 & PLAYER_STATE1_IN_WATER) ? 0.5f : 1.0f);
         }
 
-        if (!Player_InBlockingCsMode(play, this) && !(this->stateFlags2 & PLAYER_STATE2_CRAWLING)) {
-            func_8083D53C(play, this);
+        if (!Player_InBlockingCsMode(play, this) && !(this->stateFlags2 & PLAYER_STATE2_CRAWLING)) { //NOT in a cutscene and NOT crawling
+            func_8083D53C(play, this); //change audio and other functions if under water
 
             if ((this->actor.category == ACTORCAT_PLAYER) && (gSaveContext.health == 0)) {
                 if (this->stateFlags1 & (PLAYER_STATE1_HANGING_OFF_LEDGE | PLAYER_STATE1_CLIMBING_LEDGE | PLAYER_STATE1_CLIMBING_LADDER)) {
@@ -10892,7 +11431,7 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
                     func_80837B9C(this, play);
                 } else if ((this->actor.bgCheckFlags & 1) || (this->stateFlags1 & PLAYER_STATE1_IN_WATER)) {
                     func_80836448(play, this,
-                                  func_808332B8(this)       ? &gPlayerAnim_link_swimer_swim_down
+                                  PlayerIsInWaterWithoutIronBootsOn(this)       ? &gPlayerAnim_link_swimer_swim_down
                                   : (this->shockTimer != 0) ? &gPlayerAnim_link_normal_electric_shock_end
                                                             : &gPlayerAnim_link_derth_rebirth);
                 }
@@ -10935,7 +11474,7 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
 
         func_8083D6EC(play, this);
 
-        if ((this->unk_664 == NULL) && (this->naviTextId == 0)) {
+        if ((this->targetActorMaybe == NULL) && (this->naviTextId == 0)) {
             this->stateFlags2 &= ~(PLAYER_STATE2_SPEAK_OR_CHECK | PLAYER_STATE2_NAVI_ALERT);
         }
 
@@ -10945,7 +11484,7 @@ void Player_UpdateCommon(Player* this, PlayState* play, Input* input) {
                                PLAYER_STATE2_DO_ACTION_ENTER | PLAYER_STATE2_DO_ACTION_DOWN | PLAYER_STATE2_REFLECTION);
         this->stateFlags3 &= ~PLAYER_STATE3_CHECK_FLOOR_WATER_COLLISION;
 
-        func_80847298(this);
+        func_80847298(this); //Return focus to (0,0,0) slowly and turn body toward focus
         func_8083315C(play, this);
 
         if (this->stateFlags1 & PLAYER_STATE1_IN_WATER) {
@@ -11326,7 +11865,7 @@ void Player_Draw(Actor* thisx, PlayState* play2) {
         s32 lod;
         s32 pad;
 
-        if ((this->csMode != 0) || (func_8008E9C4(this) && 0) || (this->actor.projectedPos.z < 160.0f)) {
+        if ((this->csMode != 0) || (Is_PLAYER_STATE1_ENEMY_TARGET(this) && 0) || (this->actor.projectedPos.z < 160.0f)) {
             lod = 0;
         } else {
             lod = 1;
@@ -11483,7 +12022,7 @@ s16 func_8084ABD8(PlayState* play, Player* this, s32 arg2, s16 arg3) {
         }
     }
 
-    this->unk_6AE |= 2;
+    this->unk_6AE |= PLAYER_STATE4_1FIRST_PERSON_AND_MORE;
     return func_80836AB8(this, (play->shootingGalleryStatus != 0) || func_8002DD78(this) || func_808334B4(this)) -
            arg3;
 }
@@ -11586,7 +12125,7 @@ void func_8084B1D8(Player* this, PlayState* play) {
         func_8083721C(this);
     }
 
-    if ((this->unk_6AD == 2) && (func_8002DD6C(this) || func_808332E4(this))) {
+    if ((this->unk_6AD == 2) && (PlayerStateItemInHand(this) || func_808332E4(this))) {
         func_80836670(this, play);
     }
 
@@ -11595,15 +12134,17 @@ void func_8084B1D8(Player* this, PlayState* play) {
         buttonsToCheck |= BTN_DUP | BTN_DDOWN | BTN_DLEFT | BTN_DRIGHT;
     }
     if ((this->csMode != 0) || (this->unk_6AD == 0) || (this->unk_6AD >= 4) || func_80833B54(this) ||
-        (this->unk_664 != NULL) || !func_8083AD4C(play, this) ||
+        (this->targetActorMaybe != NULL) || !func_8083AD4C(play, this) ||
         (((this->unk_6AD == 2) && (CHECK_BTN_ANY(sControlInput->press.button, BTN_A | BTN_B | BTN_R) ||
-                                   func_80833B2C(this) || (!func_8002DD78(this) && !func_808334B4(this)))) ||
+                                   Is_AttemptingZTarget(this) || (!func_8002DD78(this) && !func_808334B4(this)))) ||
          ((this->unk_6AD == 1) && CHECK_BTN_ANY(sControlInput->press.button, buttonsToCheck)))) {
         func_8083C148(this, play);
         func_80078884(NA_SE_SY_CAMERA_ZOOM_UP);
     } else if ((DECR(this->unk_850) == 0) || (this->unk_6AD != 2)) {
         if (func_8008F128(this)) {
-            this->unk_6AE |= 0x43;
+            this->unk_6AE |= PLAYER_STATE4_6;
+            this->unk_6AE |= PLAYER_STATE4_1FIRST_PERSON_AND_MORE;
+            this->unk_6AE |= PLAYER_STATE4_0;
         } else {
             this->actor.shape.rot.y = func_8084ABD8(play, this, 0, 0);
         }
@@ -11613,11 +12154,11 @@ void func_8084B1D8(Player* this, PlayState* play) {
 }
 
 s32 func_8084B3CC(PlayState* play, Player* this) {
-    if (play->shootingGalleryStatus != 0) {
+    if (play->shootingGalleryStatus != 0) { //if is at the shooting gallery
         func_80832564(play, this);
         func_80835C58(play, this, func_8084FA54, 0);
 
-        if (!func_8002DD6C(this) || Player_HoldsHookshot(this)) {
+        if (!PlayerStateItemInHand(this) || Player_HoldsHookshot(this)) {
             s32 projectileItemToUse = ITEM_BOW;
             if(CVarGetInteger("gBowSlingShotAmmoFix", 0)){
                 projectileItemToUse = LINK_IS_ADULT ? ITEM_BOW : ITEM_SLINGSHOT;
@@ -11672,7 +12213,7 @@ void func_8084B530(Player* this, PlayState* play) {
                     s32 sp24 = this->unk_850;
                     func_8083A360(play, this);
                     this->unk_850 = sp24;
-                } else if (func_808332B8(this)) {
+                } else if (PlayerIsInWaterWithoutIronBootsOn(this)) {
                     func_80838F18(play, this);
                 } else {
                     func_80853080(this, play);
@@ -11686,9 +12227,9 @@ void func_8084B530(Player* this, PlayState* play) {
 
     if (this->stateFlags1 & PLAYER_STATE1_ON_HORSE) {
         func_8084CC98(this, play);
-    } else if (func_808332B8(this)) {
+    } else if (PlayerIsInWaterWithoutIronBootsOn(this)) {
         func_8084D610(this, play);
-    } else if (!func_8008E9C4(this) && LinkAnimation_Update(play, &this->skelAnime)) {
+    } else if (!Is_PLAYER_STATE1_ENEMY_TARGET(this) && LinkAnimation_Update(play, &this->skelAnime)) {
         if (this->skelAnime.moveFlags != 0) {
             func_80832DBC(this);
             if ((this->targetActor->category == ACTORCAT_NPC) &&
@@ -11702,7 +12243,7 @@ void func_8084B530(Player* this, PlayState* play) {
         }
     }
 
-    if (this->unk_664 != NULL) {
+    if (this->targetActorMaybe != NULL) {
         this->currentYaw = this->actor.shape.rot.y = func_8083DB98(this, 0);
     }
 }
@@ -12428,7 +12969,7 @@ void func_8084CC98(Player* this, PlayState* play) {
 
         if (this->stateFlags1 & PLAYER_STATE1_FIRST_PERSON) {
             if (!func_8083AD4C(play, this) || CHECK_BTN_ANY(sControlInput->press.button, BTN_A) ||
-                func_80833BCC(this)) {
+                Is_AttemptingToTargetOrTargetingEnemy(this)) {
                 this->unk_6AD = 0;
                 this->stateFlags1 &= ~PLAYER_STATE1_FIRST_PERSON;
             } else {
@@ -12440,13 +12981,13 @@ void func_8084CC98(Player* this, PlayState* play) {
         }
 
         if ((this->csMode != 0) || (!func_8084C9BC(this, play) && !func_8083B040(this, play))) {
-            if (this->unk_664 != NULL) {
+            if (this->targetActorMaybe != NULL) {
                 if (func_8002DD78(this) != 0) {
                     this->unk_6BE = func_8083DB98(this, 1) - this->actor.shape.rot.y;
                     this->unk_6BE = CLAMP(this->unk_6BE, -0x4AAA, 0x4AAA);
                     this->actor.focus.rot.y = this->actor.shape.rot.y + this->unk_6BE;
                     this->unk_6BE += 5000;
-                    this->unk_6AE |= 0x80;
+                    this->unk_6AE |= PLAYER_STATE4_7;
                 } else {
                     func_8083DB98(this, 0);
                 }
@@ -12975,7 +13516,7 @@ void func_8084E3C4(Player* this, PlayState* play) {
 void func_8084E604(Player* this, PlayState* play) {
     if (LinkAnimation_Update(play, &this->skelAnime)) {
         func_8083A098(this, &gPlayerAnim_link_normal_light_bom_end, play);
-    } else if (LinkAnimation_OnFrame(&this->skelAnime, 3.0f)) {
+    } else if (LinkAnimation_OnFrame(&this->skelAnime, 3.0f)) { //Thros a Deku Nut
         Inventory_ChangeAmmo(ITEM_NUT, -1);
         Actor_Spawn(&play->actorCtx, play, ACTOR_EN_ARROW, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].x,
                     this->bodyPartsPos[PLAYER_BODYPART_R_HAND].y, this->bodyPartsPos[PLAYER_BODYPART_R_HAND].z, 4000,
@@ -12983,7 +13524,7 @@ void func_8084E604(Player* this, PlayState* play) {
         func_80832698(this, NA_SE_VO_LI_SWORD_N);
     }
 
-    func_8083721C(this);
+    func_8083721C(this); //Set Linear Velocity to 0
 }
 
 static struct_80832924 D_808549E0[] = {
@@ -13429,7 +13970,7 @@ void func_8084F104(Player* this, PlayState* play) {
         func_80832924(this, D_80854A3C);
     }
 
-    if ((this->unk_84F == 0) && (this->unk_664 != NULL)) {
+    if ((this->unk_84F == 0) && (this->targetActorMaybe != NULL)) {
         this->currentYaw = this->actor.shape.rot.y = func_8083DB98(this, 0);
     }
 }
@@ -13607,14 +14148,14 @@ void func_8084F9C0(Player* this, PlayState* play) {
 }
 
 void func_8084FA54(Player* this, PlayState* play) {
-    this->unk_6AD = 2;
+    this->unk_6AD = 4;
 
     func_8083AD4C(play, this);
     LinkAnimation_Update(play, &this->skelAnime);
     func_80836670(this, play);
 
     this->unk_6BE = func_8084ABD8(play, this, 1, 0) - this->actor.shape.rot.y;
-    this->unk_6AE |= 0x80;
+    this->unk_6AE |= PLAYER_STATE4_7;
 
     if (play->shootingGalleryStatus < 0) {
         play->shootingGalleryStatus++;
@@ -13836,7 +14377,7 @@ void func_808502D0(Player* this, PlayState* play) {
                 u8 sp43 = this->skelAnime.moveFlags;
                 LinkAnimationHeader* sp3C;
 
-                if (func_8008E9C4(this)) {
+                if (Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                     sp3C = sp44->unk_08;
                 } else {
                     sp3C = sp44->unk_04;
@@ -14466,9 +15007,9 @@ void func_80851314(Player* this) {
         this->unk_448 = NULL;
     }
 
-    this->unk_664 = this->unk_448;
+    this->targetActorMaybe = this->unk_448;
 
-    if (this->unk_664 != NULL) {
+    if (this->targetActorMaybe != NULL) {
         this->actor.shape.rot.y = func_8083DB98(this, 0);
     }
 }
@@ -14510,7 +15051,7 @@ void func_808513BC(PlayState* play, Player* this, CsCmdActorAction* arg2) {
 void func_808514C0(PlayState* play, Player* this, CsCmdActorAction* arg2) {
     func_80851314(this);
 
-    if (func_808332B8(this)) {
+    if (PlayerIsInWaterWithoutIronBootsOn(this)) {
         func_808513BC(play, this, 0);
         return;
     }
@@ -14534,7 +15075,7 @@ void func_8085157C(PlayState* play, Player* this, CsCmdActorAction* arg2) {
 void func_808515A4(PlayState* play, Player* this, CsCmdActorAction* arg2) {
     LinkAnimationHeader* anim;
 
-    if (func_808332B8(this)) {
+    if (PlayerIsInWaterWithoutIronBootsOn(this)) {
         func_80851368(play, this, 0);
         return;
     }
@@ -14559,7 +15100,7 @@ void func_80851688(PlayState* play, Player* this, CsCmdActorAction* arg2) {
             return;
         }
 
-        if (func_808332B8(this) != 0) {
+        if (PlayerIsInWaterWithoutIronBootsOn(this) != 0) {
             func_808513BC(play, this, 0);
             return;
         }
@@ -15071,7 +15612,7 @@ void func_808528C8(PlayState* play, Player* this, CsCmdActorAction* arg2) {
 }
 
 void func_80852944(PlayState* play, Player* this, CsCmdActorAction* arg2) {
-    if (func_808332B8(this)) {
+    if (PlayerIsInWaterWithoutIronBootsOn(this)) {
         func_80838F18(play, this);
         func_80832340(play, this);
     } else {
@@ -15236,7 +15777,7 @@ s32 func_80852FFC(PlayState* play, Actor* actor, s32 csMode) {
 }
 
 void func_80853080(Player* this, PlayState* play) {
-    func_80835C58(play, this, func_80840BC8, 1);
+    func_80835C58(play, this, func_80840BC8, 1); //this? something important? maybe return to wait or normal state?
     func_80832B0C(play, this, func_80833338(this));
     this->currentYaw = this->actor.shape.rot.y;
 }
@@ -15289,13 +15830,13 @@ void func_80853148(PlayState* play, Actor* actor) {
 
             this->unk_850 = sp24;
         } else {
-            if (func_808332B8(this)) {
+            if (PlayerIsInWaterWithoutIronBootsOn(this)) {
                 func_80836898(play, this, func_8083A2F8);
                 func_80832C6C(play, this, &gPlayerAnim_link_swimer_swim_wait);
             } else if ((actor->category != ACTORCAT_NPC) || (this->heldItemAction == PLAYER_IA_FISHING_POLE)) {
                 func_8083A2F8(play, this);
 
-                if (!func_8008E9C4(this)) {
+                if (!Is_PLAYER_STATE1_ENEMY_TARGET(this)) {
                     if ((actor != this->naviActor) && (actor->xzDistToPlayer < 40.0f)) {
                         func_808322D0(play, this, &gPlayerAnim_link_normal_backspace);
                     } else {
diff --git a/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c b/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c
index 665c95b8..bcbbfbae 100644
--- a/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c
+++ b/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_item.c
@@ -16,6 +16,7 @@ static s16 sEquipAnimTimer = 0;
 static s16 sEquipMoveTimer = 10;
 bool gSelectingMask;
 bool gSelectingAdultTrade;
+int itemPage = 0;
 
 static s16 sAmmoVtxOffset[] = {
     0, 2, 4, 6, 99, 99, 8, 99, 10, 99, 99, 99, 99, 99, 12,
@@ -289,10 +290,10 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                         if (pauseCtx->cursorX[PAUSE_ITEM] != 0) {
                             pauseCtx->cursorX[PAUSE_ITEM] -= 1;
                             pauseCtx->cursorPoint[PAUSE_ITEM] -= 1;
-                            if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
-                                pauseAnyCursor) {
+                            //if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
+                            //    pauseAnyCursor) {
                                 moveCursorResult = 1;
-                            }
+                            //}
                         } else {
                             pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
                             pauseCtx->cursorY[PAUSE_ITEM] += 1;
@@ -304,7 +305,7 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                             pauseCtx->cursorPoint[PAUSE_ITEM] =
                                 pauseCtx->cursorX[PAUSE_ITEM] + (pauseCtx->cursorY[PAUSE_ITEM] * 6);
 
-                            if (pauseCtx->cursorPoint[PAUSE_ITEM] >= 24) {
+                            if (pauseCtx->cursorPoint[PAUSE_ITEM] >= 30) {
                                 pauseCtx->cursorPoint[PAUSE_ITEM] = pauseCtx->cursorX[PAUSE_ITEM];
                             }
 
@@ -321,10 +322,10 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                         if (pauseCtx->cursorX[PAUSE_ITEM] < 5) {
                             pauseCtx->cursorX[PAUSE_ITEM] += 1;
                             pauseCtx->cursorPoint[PAUSE_ITEM] += 1;
-                            if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
-                                pauseAnyCursor) {
+                            //if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
+                             //   pauseAnyCursor) {
                                 moveCursorResult = 1;
-                            }
+                            //}
                         } else {
                             pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
                             pauseCtx->cursorY[PAUSE_ITEM] += 1;
@@ -336,7 +337,7 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                             pauseCtx->cursorPoint[PAUSE_ITEM] =
                                 pauseCtx->cursorX[PAUSE_ITEM] + (pauseCtx->cursorY[PAUSE_ITEM] * 6);
 
-                            if (pauseCtx->cursorPoint[PAUSE_ITEM] >= 24) {
+                            if (pauseCtx->cursorPoint[PAUSE_ITEM] >= 30) {
                                 pauseCtx->cursorPoint[PAUSE_ITEM] = pauseCtx->cursorX[PAUSE_ITEM];
                             }
 
@@ -404,13 +405,13 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                 cursorPoint = cursorX = 5;
                 cursorY = 0;
                 while (true) {
-                    if (gSaveContext.inventory.items[cursorPoint] != ITEM_NONE) {
+                  //  if (gSaveContext.inventory.items[cursorPoint] != ITEM_NONE) {
                         pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
                         pauseCtx->cursorX[PAUSE_ITEM] = cursorX;
                         pauseCtx->cursorY[PAUSE_ITEM] = cursorY;
                         moveCursorResult = 1;
                         break;
-                    }
+                   // }
 
                     cursorY = cursorY + 1;
                     cursorPoint = cursorPoint + 6;
@@ -430,7 +431,10 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                 }
             }
         }
-
+        if (CHECK_BTN_ALL(input->press.button, BTN_A)) {
+            if (itemPage == 0) itemPage = 1;
+            else itemPage = 0;
+        }
         if (pauseCtx->cursorSpecialPos == 0) {
             if (cursorItem != PAUSE_ITEM_NONE) {
                 if ((ABS(pauseCtx->stickRelY) > 30) || (dpad && CHECK_BTN_ANY(input->press.button, BTN_DDOWN | BTN_DUP))) {
@@ -443,10 +447,10 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                             if (pauseCtx->cursorY[PAUSE_ITEM] != 0) {
                                 pauseCtx->cursorY[PAUSE_ITEM] -= 1;
                                 pauseCtx->cursorPoint[PAUSE_ITEM] -= 6;
-                                if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
-                                    pauseAnyCursor) {
+                               //if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
+                               //     pauseAnyCursor) {
                                     moveCursorResult = 1;
-                                }
+                               // }
                             } else {
                                 pauseCtx->cursorY[PAUSE_ITEM] = cursorY;
                                 pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
@@ -457,10 +461,10 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                             if (pauseCtx->cursorY[PAUSE_ITEM] < 3) {
                                 pauseCtx->cursorY[PAUSE_ITEM] += 1;
                                 pauseCtx->cursorPoint[PAUSE_ITEM] += 6;
-                                if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
-                                    pauseAnyCursor) {
+                               // if ((gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] != ITEM_NONE) ||
+                               //     pauseAnyCursor) {
                                     moveCursorResult = 1;
-                                }
+                                //}
                             } else {
                                 pauseCtx->cursorY[PAUSE_ITEM] = cursorY;
                                 pauseCtx->cursorPoint[PAUSE_ITEM] = cursorPoint;
@@ -483,12 +487,14 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
 
             if (moveCursorResult == 1) {
                 cursorItem = gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]];
+                if (itemPage == 1)cursorItem = gSaveContext.inventory.items2[pauseCtx->cursorPoint[PAUSE_ITEM]];
             } else if (moveCursorResult != 2) {
                 cursorItem = gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]];
+                if (itemPage == 1)cursorItem = gSaveContext.inventory.items2[pauseCtx->cursorPoint[PAUSE_ITEM]];
             }
 
             pauseCtx->cursorItem[PAUSE_ITEM] = cursorItem;
-            pauseCtx->cursorSlot[PAUSE_ITEM] = cursorSlot;
+            pauseCtx->cursorSlot[PAUSE_ITEM] = cursorItem;
 
             if (!CHECK_AGE_REQ_SLOT(cursorSlot)) {
                 pauseCtx->nameColorSet = 1;
@@ -566,14 +572,17 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                         buttonsToCheck |= BTN_DUP | BTN_DDOWN | BTN_DLEFT | BTN_DRIGHT;
                     }
                     if (CHECK_BTN_ANY(input->press.button, buttonsToCheck)) {
-                        if (CHECK_AGE_REQ_SLOT(cursorSlot) &&
+                        if ((CHECK_AGE_REQ_SLOT(cursorSlot) | (itemPage != 0)) &&
                             (cursorItem != ITEM_SOLD_OUT) && (cursorItem != ITEM_NONE)) {
                             KaleidoScope_SetupItemEquip(play, cursorItem, cursorSlot,
                                                         pauseCtx->itemVtx[index].v.ob[0] * 10,
                                                         pauseCtx->itemVtx[index].v.ob[1] * 10);
                         } else {
-                            Audio_PlaySoundGeneral(NA_SE_SY_ERROR, &D_801333D4, 4, &D_801333E0, &D_801333E0,
-                                                   &D_801333E8);
+                            KaleidoScope_SetupItemEquip(play, ITEM_NONE, cursorSlot,
+                                pauseCtx->itemVtx[index].v.ob[0] * 10,
+                                pauseCtx->itemVtx[index].v.ob[1] * 10);
+                            //Audio_PlaySoundGeneral(NA_SE_SY_ERROR, &D_801333D4, 4, &D_801333E0, &D_801333E0,
+                            //                      &D_801333E8);
                         }
                     }
                 }
@@ -605,8 +614,14 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
         if ((gSaveContext.equips.buttonItems[i + 1] != ITEM_NONE) &&
             !((gSaveContext.equips.buttonItems[i + 1] >= ITEM_SHIELD_DEKU) &&
               (gSaveContext.equips.buttonItems[i + 1] <= ITEM_BOOTS_HOVER))) {
-            gSPVertex(POLY_KAL_DISP++, &pauseCtx->itemVtx[j], 4, 0);
-            POLY_KAL_DISP = KaleidoScope_QuadTextureIA8(POLY_KAL_DISP, gEquippedItemOutlineTex, 32, 32, 0);
+            if ((itemPage == 0) & (gSaveContext.equips.buttonItems[i + 1] < ITEM_JUMP)) { //ITEM_JUMP is first Custom
+                gSPVertex(POLY_KAL_DISP++, &pauseCtx->itemVtx[j], 4, 0);
+                POLY_KAL_DISP = KaleidoScope_QuadTextureIA8(POLY_KAL_DISP, gEquippedItemOutlineTex, 32, 32, 0);
+            } //CUSTOM
+            if ((itemPage == 1) & (gSaveContext.equips.buttonItems[i + 1] >= ITEM_JUMP)) {
+                gSPVertex(POLY_KAL_DISP++, &pauseCtx->itemVtx[j], 4, 0);
+                POLY_KAL_DISP = KaleidoScope_QuadTextureIA8(POLY_KAL_DISP, gEquippedItemOutlineTex, 32, 32, 0);
+            }
         }
     }
 
@@ -616,7 +631,7 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
     for (i = j = 0; i < 24; i++, j += 4) {
         gDPSetPrimColor(POLY_KAL_DISP++, 0, 0, 255, 255, 255, pauseCtx->alpha);
 
-        if (gSaveContext.inventory.items[i] != ITEM_NONE) {
+        if ((gSaveContext.inventory.items[i] != ITEM_NONE) | (itemPage == 1)) {
             if ((pauseCtx->unk_1E4 == 0) && (pauseCtx->pageIndex == PAUSE_ITEM) && (pauseCtx->cursorSpecialPos == 0)) {
                 if (CHECK_AGE_REQ_SLOT(i)) {
                     if ((sEquipState == 2) && (i == 3)) {
@@ -635,7 +650,8 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
 
                         pauseCtx->itemVtx[j + 2].v.ob[1] = pauseCtx->itemVtx[j + 3].v.ob[1] =
                             pauseCtx->itemVtx[j + 0].v.ob[1] - 32;
-                    } else if (i == cursorSlot) {
+                    }
+                    else if (i == cursorSlot) {
                         pauseCtx->itemVtx[j + 0].v.ob[0] = pauseCtx->itemVtx[j + 2].v.ob[0] =
                             pauseCtx->itemVtx[j + 0].v.ob[0] - 2;
 
@@ -650,16 +666,31 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
                     }
                 }
             }
-
+            int itemId = 0;
+            if (itemPage == 0) {
             gSPVertex(POLY_KAL_DISP++, &pauseCtx->itemVtx[j + 0], 4, 0);
-            int itemId = gSaveContext.inventory.items[i];
+                itemId = gSaveContext.inventory.items[i];
             bool not_acquired = !CHECK_AGE_REQ_ITEM(itemId);
             if (not_acquired) {
                 gDPSetGrayscaleColor(POLY_KAL_DISP++, 109, 109, 109, 255);
                 gSPGrayscale(POLY_KAL_DISP++, true);
             }
+            }
+            else if (itemPage == 1) {
+                gSPVertex(POLY_KAL_DISP++, &pauseCtx->itemVtx[j + 0], 4, 0);
+                itemId = gSaveContext.inventory.items2[i];
+            }
+            if (itemPage == 0) {
             KaleidoScope_DrawQuadTextureRGBA32(play->state.gfxCtx, gItemIcons[itemId], 32,
                                                32, 0);
+            }
+            else if (itemPage == 1) {
+                //CUSTOM
+                if (i < ITEM_CUSTOM_MAX - ITEM_JUMP) { ///CUSTOM
+                    KaleidoScope_DrawQuadTextureRGBA32(play->state.gfxCtx, gItemIcons[itemId], 32,
+                        32, 0);
+                }
+            }
             gSPGrayscale(POLY_KAL_DISP++, false);
         }
     }
@@ -674,7 +705,7 @@ void KaleidoScope_DrawItemSelect(PlayState* play) {
 
     for (i = 0; i < 15; i++) {
         if ((gAmmoItems[i] != ITEM_NONE) && (gSaveContext.inventory.items[i] != ITEM_NONE)) {
-            KaleidoScope_DrawAmmoCount(pauseCtx, play->state.gfxCtx, gSaveContext.inventory.items[i], i);
+           if (itemPage == 0) KaleidoScope_DrawAmmoCount(pauseCtx, play->state.gfxCtx, gSaveContext.inventory.items[i], i);
         }
     }
 
@@ -717,6 +748,11 @@ void KaleidoScope_SetupItemEquip(PlayState* play, u16 item, u16 slot, s16 animX,
 
     pauseCtx->equipTargetItem = item;
     pauseCtx->equipTargetSlot = slot;
+    if (itemPage == 1) {
+    }
+    //CUSTOM
+    if (pauseCtx->equipTargetItem > ITEM_CUSTOM_MAX - 1) pauseCtx->equipTargetItem = ITEM_NONE;
+    if (pauseCtx->equipTargetSlot > SLOT_CUSTOM_MAX - 1) pauseCtx->equipTargetSlot = SLOT_NONE;
     pauseCtx->unk_1E4 = 3;
     pauseCtx->equipAnimX = animX;
     pauseCtx->equipAnimY = animY;
@@ -1030,20 +1066,21 @@ void KaleidoScope_UpdateItemEquip(PlayState* play) {
             
             // If the item is on another button already, swap the two
             uint16_t targetButtonIndex = pauseCtx->equipTargetCBtn + 1;
-            for (uint16_t otherSlotIndex = 0; otherSlotIndex < ARRAY_COUNT(gSaveContext.equips.cButtonSlots);
-                 otherSlotIndex++) {
+            for (uint16_t otherSlotIndex = 0; otherSlotIndex < ARRAY_COUNT(gSaveContext.equips.cButtonSlots); otherSlotIndex++)
+            {
                 uint16_t otherButtonIndex = otherSlotIndex + 1;
-                if (otherSlotIndex == pauseCtx->equipTargetCBtn) {
-                    continue;
+                if (otherSlotIndex == pauseCtx->equipTargetCBtn) { //if "otherSlotIndex" is the same a c button we pressed 
+                    continue;                                      //the item is placed on top of itself, does not need to swap
+                }
+                if (gSaveContext.equips.buttonItems[otherButtonIndex] != pauseCtx->equipTargetItem) { //if "otherSlotIndex" is the same a c button we pressed 
+                    continue;                                      
                 }
 
                 if (pauseCtx->equipTargetSlot == gSaveContext.equips.cButtonSlots[otherSlotIndex]) {
                     // Assign the other button to the target's current item
                     if (gSaveContext.equips.buttonItems[targetButtonIndex] != ITEM_NONE) {
-                        gSaveContext.equips.buttonItems[otherButtonIndex] =
-                            gSaveContext.equips.buttonItems[targetButtonIndex];
-                        gSaveContext.equips.cButtonSlots[otherSlotIndex] =
-                            gSaveContext.equips.cButtonSlots[pauseCtx->equipTargetCBtn];
+                        gSaveContext.equips.buttonItems[otherButtonIndex] = gSaveContext.equips.buttonItems[targetButtonIndex];
+                        gSaveContext.equips.cButtonSlots[otherSlotIndex] = gSaveContext.equips.cButtonSlots[pauseCtx->equipTargetCBtn];
                         Interface_LoadItemIcon2(play, otherButtonIndex);
                     } else {
                         gSaveContext.equips.buttonItems[otherButtonIndex] = ITEM_NONE;
diff --git a/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope_PAL.c b/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope_PAL.c
index 35490f07..87981463 100644
--- a/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope_PAL.c
+++ b/soh/src/overlays/misc/ovl_kaleido_scope/z_kaleido_scope_PAL.c
@@ -2209,9 +2209,29 @@ void KaleidoScope_UpdateNamePanel(PlayState* play) {
         (pauseCtx->pageIndex == PAUSE_ITEM && gSaveContext.inventory.items[pauseCtx->cursorPoint[PAUSE_ITEM]] == ITEM_NONE))) {
             pauseCtx->namedItem = PAUSE_ITEM_NONE;
         }
-
+        //CUSTOM
         if (pauseCtx->namedItem != PAUSE_ITEM_NONE) {
-            if ((pauseCtx->pageIndex == PAUSE_MAP) && !sInDungeonScene) {
+            if (pauseCtx->namedItem == ITEM_NONE) {
+                const char* textureName = gBlankItemNameENGTex;
+                memcpy(pauseCtx->nameSegment, textureName, strlen(textureName) + 1);
+            }
+            else if (pauseCtx->namedItem == ITEM_JUMP) {
+                const char* textureName = gSSBJumpItemNameENGTex;
+                memcpy(pauseCtx->nameSegment, textureName, strlen(textureName) + 1);
+            }
+            else if (pauseCtx->namedItem == ITEM_GLIDER) {
+                const char* textureName = gGliderItemNameENGTex;
+                memcpy(pauseCtx->nameSegment, textureName, strlen(textureName) + 1);
+            }
+            else if (pauseCtx->namedItem == ITEM_LANTERN) {
+                const char* textureName = gLanternItemNameENGTex;
+                memcpy(pauseCtx->nameSegment, textureName, strlen(textureName) + 1);
+            }
+            else if (pauseCtx->namedItem == ITEM_STASIS) {
+                const char* textureName = gStasisItemNameENGTex;
+                memcpy(pauseCtx->nameSegment, textureName, strlen(textureName) + 1);
+            }
+            else if ((pauseCtx->pageIndex == PAUSE_MAP) && !sInDungeonScene) {
                 if (gSaveContext.language) {
                     sp2A += 12;
                 }
